# TDengine SQL 函数大全

-- 以下内容来自 TDengine 官方文档 https://docs.taosdata.com/taos-sql/function/
及 GitHub 内容 https://github.com/taosdata/TDengine.git

-- 以下所有示例基于 TDengine 3.1.0.3

### 数学函数

#### ABS

```sql
ABS(expr)
```

**功能说明**：获得指定字段的绝对值。

**返回结果类型**：与指定字段的原始数据类型一致。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:

写入示例数据
```sql
CREATE TABLE `t1` (`ts` TIMESTAMP, `v1` INT, `v2` DOUBLE, `v3` FLOAT);
insert into t1 values(now,1,1,1);
insert into t1 values(now,-1,-1,-1);
insert into t1 values(now,0.5,0.5,0.5);
```
```sql

taos> select * from t1;
           ts            |     v1      |            v2             |          v3          |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:34:01.888 |           1 |         0.500000000000000 |            0.5000000 |
Query OK, 3 row(s) in set (0.002018s)
```

```sql
> select ts,abs(v1),abs(v2),abs(v3) from t1 limit 10;
           ts            |   abs(v1)   |          abs(v2)          |       abs(v3)        |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:34:01.888 |           1 |         0.500000000000000 |            0.5000000 |

> select ts,abs(v1) from (select * from t1 limit 10);
           ts            |   abs(v1)   |
========================================
 2023-08-30 14:33:06.691 |           1 |
 2023-08-30 14:33:12.034 |           1 |
 2023-08-30 14:34:01.888 |           1 |

> select ts, case when v1<0 then abs(v1) else v1 end from t1 limit 10;
           ts            | case when v1<0 then abs(v1) else v1 end |
====================================================================
 2023-08-30 14:33:06.691 |                                       1 |
 2023-08-30 14:33:12.034 |                                       1 |
 2023-08-30 14:34:01.888 |                                       1 |

> select ts,abs(-1),v1 from t1 limit 2;
           ts            |        abs(-1)        |     v1      |
================================================================
 2023-08-30 14:33:06.691 |                     1 |           1 |
 2023-08-30 14:33:12.034 |                     1 |          -1 |

```

#### ACOS

```sql
ACOS(expr)
```

**功能说明**：获得指定字段的反余弦结果。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：
- 只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。
- 反余弦的取值范围为 [-1,+1]，超过取值范围返回 `NULL`。

**示例**:
```sql
> select ts,v2 from t1;
           ts            |            v2             |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |        -1.000000000000000 |
 2023-08-30 14:34:01.888 |         0.500000000000000 |

> select ts,acos(v2) from t1;
           ts            |         acos(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         0.000000000000000 |
 2023-08-30 14:33:12.034 |         3.141592653589793 |
 2023-08-30 14:34:01.888 |         1.047197551196598 |

> select ts,acos(v2) from (select ts,v2 from t1) limit 3;
           ts            |         acos(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         0.000000000000000 |
 2023-08-30 14:33:12.034 |         3.141592653589793 |
 2023-08-30 14:34:01.888 |         1.047197551196598 |

> insert into t1 values(now,1,2,3);
> select ts,acos(v2) from t1;
           ts            |         acos(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         0.000000000000000 |
 2023-08-30 14:33:12.034 |         3.141592653589793 |
 2023-08-30 14:34:01.888 |         1.047197551196598 |
 2023-08-30 14:48:32.507 | NULL                      |

```

#### ASIN

```sql
ASIN(expr)
```

**功能说明**：获得指定字段的反正弦结果。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：
- 只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。
- 反正弦的取值范围为 [-1,+1]，超过取值范围返回 `NULL`。

**示例**:
```sql
> select * from t1;
           ts            |     v1      |            v2             |          v3          |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:34:01.888 |           1 |         0.500000000000000 |            0.5000000 |
 2023-08-30 14:48:32.507 |           1 |         2.000000000000000 |            3.0000000 |

> select ts,asin(v2) from t1;
           ts            |         asin(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         1.570796326794897 |
 2023-08-30 14:33:12.034 |        -1.570796326794897 |
 2023-08-30 14:34:01.888 |         0.523598775598299 |
 2023-08-30 14:48:32.507 | NULL                      |

> select ts,asin(v2) from (select * from t1);
           ts            |         asin(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         1.570796326794897 |
 2023-08-30 14:33:12.034 |        -1.570796326794897 |
 2023-08-30 14:34:01.888 |         0.523598775598299 |
 2023-08-30 14:48:32.507 | NULL 
```

#### ATAN

```sql
ATAN(expr)
```

**功能说明**：获得指定字段的反正切结果。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:
```sql
> select * from t1;
           ts            |     v1      |            v2             |          v3          |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:34:01.888 |           1 |         0.500000000000000 |            0.5000000 |
 2023-08-30 14:48:32.507 |           1 |         2.000000000000000 |            3.0000000 |

> select ts,atan(v2) from t1 ;
           ts            |         atan(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         0.785398163397448 |
 2023-08-30 14:33:12.034 |        -0.785398163397448 |
 2023-08-30 14:34:01.888 |         0.463647609000806 |
 2023-08-30 14:48:32.507 |         1.107148717794090 |

> select ts,atan(v2) from (select * from t1);
           ts            |         atan(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         0.785398163397448 |
 2023-08-30 14:33:12.034 |        -0.785398163397448 |
 2023-08-30 14:34:01.888 |         0.463647609000806 |
 2023-08-30 14:48:32.507 |         1.107148717794090 |
```

#### CEIL

```sql
CEIL(expr)
```

**功能说明**：获得指定字段的向上取整数的结果。

**返回结果类型**：与指定字段的原始数据类型一致。

**适用数据类型**：数值类型。

**适用于**: 表和超级表。

**嵌套子查询支持**：适用于内层查询和外层查询。

**使用说明**: 只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:
```sql
> select * from t1;
           ts            |     v1      |            v2             |          v3          |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:34:01.888 |           1 |         0.500000000000000 |            0.5000000 |
 2023-08-30 14:48:32.507 |           1 |         2.000000000000000 |            3.0000000 |
 2023-08-30 14:59:58.363 |           2 |         0.200000000000000 |            0.2000000 |

> select ts,ceil(v2) from t1 ;
           ts            |         ceil(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |        -1.000000000000000 |
 2023-08-30 14:34:01.888 |         1.000000000000000 |
 2023-08-30 14:48:32.507 |         2.000000000000000 |
 2023-08-30 14:59:58.363 |         1.000000000000000 |

> select ts,ceil(v2) from (select * from t1);
           ts            |         ceil(v2)          |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |        -1.000000000000000 |
 2023-08-30 14:34:01.888 |         1.000000000000000 |
 2023-08-30 14:48:32.507 |         2.000000000000000 |
 2023-08-30 14:59:58.363 |         1.000000000000000 |
```

#### COS

```sql
COS(expr)
```

**功能说明**：获得指定字段的余弦结果。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**：
```sql
> select * from t1;
           ts            |     v1      |            v2             |          v3          |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:34:01.888 |           1 |         0.500000000000000 |            0.5000000 |
 2023-08-30 14:48:32.507 |           1 |         2.000000000000000 |            3.0000000 |
 2023-08-30 14:59:58.363 |           2 |         0.200000000000000 |            0.2000000 |

> select ts,cos(v3) from t1;
           ts            |          cos(v3)          |
======================================================
 2023-08-30 14:33:06.691 |         0.540302305868140 |
 2023-08-30 14:33:12.034 |         0.540302305868140 |
 2023-08-30 14:34:01.888 |         0.877582561890373 |
 2023-08-30 14:48:32.507 |        -0.989992496600445 |
 2023-08-30 14:59:58.363 |         0.980066577249161 |

> select ts,cos(v3) from (select * from t1);
           ts            |          cos(v3)          |
======================================================
 2023-08-30 14:33:06.691 |         0.540302305868140 |
 2023-08-30 14:33:12.034 |         0.540302305868140 |
 2023-08-30 14:34:01.888 |         0.877582561890373 |
 2023-08-30 14:48:32.507 |        -0.989992496600445 |
 2023-08-30 14:59:58.363 |         0.980066577249161 |

> SELECT COS(60*3.14159265359/180) FROM t1 limit 1;
 cos(60*3.14159265359/180) |
============================
         0.499999999999940 |
```

#### FLOOR

```sql
FLOOR(expr)
```

**功能说明**：获得指定字段的向下取整数的结果。
 其他使用说明参见 CEIL 函数描述。

**示例**:
```sql
select * from t1;
           ts            |     v1      |            v2             |          v3          |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:34:01.888 |           1 |         0.500000000000000 |            0.5000000 |
 2023-08-30 14:48:32.507 |           1 |         2.000000000000000 |            3.0000000 |
 2023-08-30 14:59:58.363 |           2 |         0.200000000000000 |            0.2000000 |

> select ts,floor(v2) from t1;
           ts            |         floor(v2)         |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |        -1.000000000000000 |
 2023-08-30 14:34:01.888 |         0.000000000000000 |
 2023-08-30 14:48:32.507 |         2.000000000000000 |
 2023-08-30 14:59:58.363 |         0.000000000000000 |

> select ts,floor(v2) from (select * from t1);
           ts            |         floor(v2)         |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |        -1.000000000000000 |
 2023-08-30 14:34:01.888 |         0.000000000000000 |
 2023-08-30 14:48:32.507 |         2.000000000000000 |
 2023-08-30 14:59:58.363 |         0.000000000000000 |
```


#### LOG

```sql
LOG(expr1[, expr2])
```

**功能说明**：获得 expr1 对于底数 expr2 的对数。如果 expr2 参数省略，则返回指定字段的自然对数值。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:
```sql
> select ts,v1 from t1;
           ts            |     v1      |
========================================
 2023-08-30 14:33:06.691 |           1 |
 2023-08-30 14:33:12.034 |          -1 |
 2023-08-30 14:48:32.507 |           1 |
 2023-08-30 14:59:58.363 |           2 |
 2023-08-30 16:25:28.882 |           4 |

> select ts,log(v1) from t1;
           ts            |          log(v1)          |
======================================================
 2023-08-30 14:33:06.691 |         0.000000000000000 |
 2023-08-30 14:33:12.034 | NULL                      |
 2023-08-30 14:48:32.507 |         0.000000000000000 |
 2023-08-30 14:59:58.363 |         0.693147180559945 |
 2023-08-30 16:25:28.882 |         1.386294361119891 |

> select ts,log(v1,2) from t1;
           ts            |         log(v1,2)         |
======================================================
 2023-08-30 14:33:06.691 |         0.000000000000000 |
 2023-08-30 14:33:12.034 | NULL                      |
 2023-08-30 14:48:32.507 |         0.000000000000000 |
 2023-08-30 14:59:58.363 |         1.000000000000000 |
 2023-08-30 16:25:28.882 |         2.000000000000000 |

> select ts,log(v1,2) from (select * from t1);
           ts            |         log(v1,2)         |
======================================================
 2023-08-30 14:33:06.691 |         0.000000000000000 |
 2023-08-30 14:33:12.034 | NULL                      |
 2023-08-30 14:48:32.507 |         0.000000000000000 |
 2023-08-30 14:59:58.363 |         1.000000000000000 |
 2023-08-30 16:25:28.882 |         2.000000000000000 |

> select log(1024,2) from t1 limit 1;
        log(1024,2)        |
============================
        10.000000000000000 |
```

#### POW

```sql
POW(expr1, expr2)
```

**功能说明**：获得 expr1 的指数为 expr2 的幂。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:
```sql
> select ts,v1 from t1;
           ts            |     v1      |
========================================
 2023-08-30 14:33:06.691 |           1 |
 2023-08-30 14:33:12.034 |          -1 |
 2023-08-30 14:48:32.507 |           1 |
 2023-08-30 14:59:58.363 |           2 |
 2023-08-30 16:25:28.882 |           4 |

> select ts,pow(v1,2) from t1;
           ts            |         pow(v1,2)         |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |         1.000000000000000 |
 2023-08-30 14:48:32.507 |         1.000000000000000 |
 2023-08-30 14:59:58.363 |         4.000000000000000 |
 2023-08-30 16:25:28.882 |        16.000000000000000 |

> select ts,pow(2,v1) from t1;
           ts            |         pow(2,v1)         |
======================================================
 2023-08-30 14:33:06.691 |         2.000000000000000 |
 2023-08-30 14:33:12.034 |         0.500000000000000 |
 2023-08-30 14:48:32.507 |         2.000000000000000 |
 2023-08-30 14:59:58.363 |         4.000000000000000 |
 2023-08-30 16:25:28.882 |        16.000000000000000 |

> select ts,pow(v1,v1) from t1;
           ts            |        pow(v1,v1)         |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |        -1.000000000000000 |
 2023-08-30 14:48:32.507 |         1.000000000000000 |
 2023-08-30 14:59:58.363 |         4.000000000000000 |
 2023-08-30 16:25:28.882 |       256.000000000000000 |

> select ts,pow(v1,v2) from (select * from t1);
           ts            |        pow(v1,v2)         |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 |        -1.000000000000000 |
 2023-08-30 14:48:32.507 |         1.000000000000000 |
 2023-08-30 14:59:58.363 |         1.148698354997035 |
 2023-08-30 16:25:28.882 |       256.000000000000000 |

> select pow(2,10) from t1 limit 1;
         pow(2,10)         |
============================
      1024.000000000000000 |
```


#### ROUND

```sql
ROUND(expr)
```

**功能说明**：获得指定字段的四舍五入的结果。
 其他使用说明参见 CEIL 函数描述。

**示例**:
```sql
> select * from t1;
           ts            |     v1      |            v2             |          v3          |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:48:32.507 |           1 |         2.000000000000000 |            3.0000000 |
 2023-08-30 14:59:58.363 |           2 |         0.200000000000000 |            0.2000000 |
 2023-08-30 16:25:28.882 |           4 |         4.000000000000000 |            4.0000000 |
 2023-08-30 16:39:29.246 |           1 |         0.600000000000000 |            0.4000000 |

> select ts,round(v1),round(v2),round(v3) from t1;
           ts            |  round(v1)  |         round(v2)         |      round(v3)       |
===========================================================================================
 2023-08-30 14:33:06.691 |           1 |         1.000000000000000 |            1.0000000 |
 2023-08-30 14:33:12.034 |          -1 |        -1.000000000000000 |           -1.0000000 |
 2023-08-30 14:48:32.507 |           1 |         2.000000000000000 |            3.0000000 |
 2023-08-30 14:59:58.363 |           2 |         0.000000000000000 |            0.0000000 |
 2023-08-30 16:25:28.882 |           4 |         4.000000000000000 |            4.0000000 |
 2023-08-30 16:39:29.246 |           1 |         1.000000000000000 |            0.0000000 |
Query OK, 6 row(s) in set (0.003281s)
```

#### SIN

```sql
SIN(expr)
```

**功能说明**：获得指定字段的正弦结果。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:
```sql
> select ts,v1 from t1;
           ts            |     v1      |
========================================
 2023-08-30 14:33:06.691 |           1 |
 2023-08-30 14:33:12.034 |          -1 |
 2023-08-30 14:48:32.507 |           1 |
 2023-08-30 14:59:58.363 |           2 |
 2023-08-30 16:25:28.882 |           4 |
 2023-08-30 16:39:29.246 |           1 |

> select ts,sin(v1) from t1;
           ts            |          sin(v1)          |
======================================================
 2023-08-30 14:33:06.691 |         0.841470984807897 |
 2023-08-30 14:33:12.034 |        -0.841470984807897 |
 2023-08-30 14:48:32.507 |         0.841470984807897 |
 2023-08-30 14:59:58.363 |         0.909297426825682 |
 2023-08-30 16:25:28.882 |        -0.756802495307928 |
 2023-08-30 16:39:29.246 |         0.841470984807897 |

> select ts,sin(v1) from (select * from t1);
           ts            |          sin(v1)          |
======================================================
 2023-08-30 14:33:06.691 |         0.841470984807897 |
 2023-08-30 14:33:12.034 |        -0.841470984807897 |
 2023-08-30 14:48:32.507 |         0.841470984807897 |
 2023-08-30 14:59:58.363 |         0.909297426825682 |
 2023-08-30 16:25:28.882 |        -0.756802495307928 |
 2023-08-30 16:39:29.246 |         0.841470984807897 |

> select sin(90*3.1415926/180) from t1 limit 1;
   sin(90*3.1415926/180)   |
============================
         1.000000000000000 |

> select sin(30*3.1415926/180) from t1 limit 1;
   sin(30*3.1415926/180)   |
============================
         0.499999992264980 |
```

#### SQRT

```sql
SQRT(expr)
```

**功能说明**：获得指定字段的平方根。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:
```sql
> select ts,v1 from t1;
           ts            |     v1      |
========================================
 2023-08-30 14:33:06.691 |           1 |
 2023-08-30 14:33:12.034 |          -1 |
 2023-08-30 14:48:32.507 |           1 |
 2023-08-30 14:59:58.363 |           2 |
 2023-08-30 16:25:28.882 |           4 |
 2023-08-30 16:39:29.246 |           1 |

> select ts,sqrt(v1) from t1;
           ts            |         sqrt(v1)          |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 | NULL                      |
 2023-08-30 14:48:32.507 |         1.000000000000000 |
 2023-08-30 14:59:58.363 |         1.414213562373095 |
 2023-08-30 16:25:28.882 |         2.000000000000000 |
 2023-08-30 16:39:29.246 |         1.000000000000000 |

> select ts,sqrt(v1) from (select * from t1);
           ts            |         sqrt(v1)          |
======================================================
 2023-08-30 14:33:06.691 |         1.000000000000000 |
 2023-08-30 14:33:12.034 | NULL                      |
 2023-08-30 14:48:32.507 |         1.000000000000000 |
 2023-08-30 14:59:58.363 |         1.414213562373095 |
 2023-08-30 16:25:28.882 |         2.000000000000000 |
 2023-08-30 16:39:29.246 |         1.000000000000000 |

> select sqrt(100),sqrt(4) from t1 limit 1;
         sqrt(100)         |          sqrt(4)          |
========================================================
        10.000000000000000 |         2.000000000000000 |
Query OK, 1 row(s) in set (0.001785s)
```


#### TAN

```sql
TAN(expr)
```

**功能说明**：获得指定字段的正切结果。

**返回结果类型**：DOUBLE。

**适用数据类型**：数值类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用。

**示例**:
```sql
> select ts,v1 from t1;
           ts            |     v1      |
========================================
 2023-08-30 14:33:06.691 |           1 |
 2023-08-30 14:33:12.034 |          -1 |
 2023-08-30 14:48:32.507 |           1 |
 2023-08-30 14:59:58.363 |           2 |
 2023-08-30 16:25:28.882 |           4 |
 2023-08-30 16:39:29.246 |           1 |

> select ts,tan(v1) from t1;
           ts            |          tan(v1)          |
======================================================
 2023-08-30 14:33:06.691 |         1.557407724654902 |
 2023-08-30 14:33:12.034 |        -1.557407724654902 |
 2023-08-30 14:48:32.507 |         1.557407724654902 |
 2023-08-30 14:59:58.363 |        -2.185039863261519 |
 2023-08-30 16:25:28.882 |         1.157821282349577 |
 2023-08-30 16:39:29.246 |         1.557407724654902 |

> select ts,tan(v1) from (select * from t1);
           ts            |          tan(v1)          |
======================================================
 2023-08-30 14:33:06.691 |         1.557407724654902 |
 2023-08-30 14:33:12.034 |        -1.557407724654902 |
 2023-08-30 14:48:32.507 |         1.557407724654902 |
 2023-08-30 14:59:58.363 |        -2.185039863261519 |
 2023-08-30 16:25:28.882 |         1.157821282349577 |
 2023-08-30 16:39:29.246 |         1.557407724654902 |

> select tan(45*3.1415926/180) from t1 limit 1;
   tan(45*3.1415926/180)   |
============================
         0.999999973205104 |

> select tan(90*3.1415926/180) from t1 limit 1;
   tan(90*3.1415926/180)   |
============================
  37320539.634354814887047 |
```

### 字符串函数

字符串函数的输入参数为字符串类型，返回结果为数值类型或字符串类型。

#### CHAR_LENGTH

```sql
CHAR_LENGTH(expr)
```

**功能说明**：以字符计数的字符串长度。

**返回结果类型**：BIGINT。

**适用数据类型**：VARCHAR(BINARY), NCHAR。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**:
写入测试数据
```sql
> create table t2(ts timestamp,v1 nchar(100),v2 binary(100));
> insert into t2 values(now,'1234567890','1234567890');
> insert into t2 values(now,'abcdefghijklmnopq','abcdefghijklmnopq');
> select * from t2;
           ts            |               v1               |               v2               |
============================================================================================
 2023-08-30 16:50:51.997 | 1234567890                     | 1234567890                     |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq              | abcdefghijklmnopq              |
```
```sql
> select * from t2;
           ts            |               v1               |               v2               |
============================================================================================
 2023-08-30 16:50:51.997 | 1234567890                     | 1234567890                     |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq              | abcdefghijklmnopq              |

> select ts,char_length(v1),char_length(v2) from t2;
           ts            |    char_length(v1)    |    char_length(v2)    |
==========================================================================
 2023-08-30 16:50:51.997 |                    10 |                    10 |
 2023-08-30 16:51:13.694 |                    17 |                    17 |

> select ts,char_length(v1),char_length(v2) from (select * from t2);
           ts            |    char_length(v1)    |    char_length(v2)    |
==========================================================================
 2023-08-30 16:50:51.997 |                    10 |                    10 |
 2023-08-30 16:51:13.694 |                    17 |                    17 |

> select char_length('1234567890')  from t2 limit 1;
 char_length('1234567890') |
============================
                        10 |
```

#### CONCAT

```sql
CONCAT(expr1, expr2 [, expr] ... )
```

**功能说明**：字符串连接函数。

**返回结果类型**：如果所有参数均为 VARCHAR 类型，则结果类型为 VARCHAR。如果参数包含NCHAR类型，则结果类型为NCHAR。如果参数包含NULL值，则输出值为NULL。

**适用数据类型**：VARCHAR, NCHAR。 该函数最小参数个数为2个，最大参数个数为8个。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**:
```sql
> select * from t2;
           ts            |               v1               |               v2               |
============================================================================================
 2023-08-30 16:50:51.997 | 1234567890                     | 1234567890                     |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq              | abcdefghijklmnopq              |

> select ts,concat(v1,v2) from t2;
           ts            |         concat(v1,v2)          |
===========================================================
 2023-08-30 16:50:51.997 | 12345678901234567890           |
 2023-08-30 16:51:13.694 | abcdefghijklmnopqabcdefghij... |

> select ts,char_length(concat(v1,v2)) from t2;
           ts            | char_length(concat(v1,v2)) |
=======================================================
 2023-08-30 16:50:51.997 |                         20 |
 2023-08-30 16:51:13.694 |                         34 |

> select ts,concat(v1,v1,v2,v2) from t2;
           ts            |      concat(v1,v1,v2,v2)       |
===========================================================
 2023-08-30 16:50:51.997 | 123456789012345678901234567... |
 2023-08-30 16:51:13.694 | abcdefghijklmnopqabcdefghij... |

> select ts,char_length(concat(v1,v1,v2,v2)) from t2;
           ts            | char_length(concat(v1,v1,v2,v2)) |
=============================================================
 2023-08-30 16:50:51.997 |                               40 |
 2023-08-30 16:51:13.694 |                               68 |

> select concat('CONCAT ','funcation ','test!') from t2 limit 1;
 concat('CONCAT ','funcation ','test!') |
=========================================
 CONCAT funcation test!                 |

> select char_length(concat('CONCAT ','funcation ','test!')) from t2 limit 1;
 char_length(concat('CONCAT ','funcation ','test!')) |
======================================================
                                                  22 |
>  select concat('a','b','c','d','e','f','g','h') from t2 limit 1;
 concat('a','b','c','d','e','f','g','h') |
==========================================
 abcdefgh                                |

> select concat('a','b','c','d','e','f','g','h','i') from t2 limit 1;
DB error: Invalid number of parameters : concat (0.000437s)

> select concat('a') from t2 limit 1;
DB error: Invalid number of parameters : concat (0.000223s)                                                  
```

#### CONCAT_WS

```sql
CONCAT_WS(separator_expr, expr1, expr2 [, expr] ...)
```

**功能说明**：带分隔符的字符串连接函数。

**返回结果类型**：如果所有参数均为VARCHAR类型，则结果类型为VARCHAR。如果参数包含NCHAR类型，则结果类型为NCHAR。如果参数包含NULL值，则输出值为NULL。

**适用数据类型**：VARCHAR, NCHAR。 该函数最小参数个数为3个，最大参数个数为9个。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**:
```sql
> select * from t2;
           ts            |               v1               |               v2               |
============================================================================================
 2023-08-30 16:50:51.997 | 1234567890                     | 1234567890                     |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq              | abcdefghijklmnopq              |

> select ts,concat_ws(',',v1,v2) from t2;
           ts            |      concat_ws(',',v1,v2)      |
===========================================================
 2023-08-30 16:50:51.997 | 1234567890,1234567890          |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq,abcdefghi... |

> select ts,concat_ws(',',v1,v2,v1,v2) from t2;
           ts            |   concat_ws(',',v1,v2,v1,v2)   |
===========================================================
 2023-08-30 16:50:51.997 | 1234567890,1234567890,12345... |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq,abcdefghi... |

> set max_binary_display_width 60;
> select ts,concat_ws(',',v1,v2,v1,v2) from t2;
           ts            |                  concat_ws(',',v1,v2,v1,v2)                  |
=========================================================================================
 2023-08-30 16:50:51.997 | 1234567890,1234567890,1234567890,1234567890                  |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq,abcdefghijklmnopq,abcdefghijklmnopq,abc... |

> select concat_ws(' ','a','b','c','d','e','f','g','h') from t2 limit 1;
 concat_ws(' ','a','b','c','d','e','f','g','h') |
=================================================
 a b c d e f g h                                |
```

#### LENGTH

```sql
LENGTH(expr)
```

**功能说明**：以字节计数的字符串长度。

**返回结果类型**：BIGINT。

**适用数据类型**：输入参数是 VARCHAR 类型或者 NCHAR 类型的字符串或者列。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**:
```sql
> desc t2;
                  field                   |          type          |   length    |    note    |
===============================================================================================
 ts                                       | TIMESTAMP              |           8 |            |
 v1                                       | NCHAR                  |         100 |            |
 v2                                       | VARCHAR                |         100 |            |

> select ts,v1 from t2;
           ts            |                    v1                    |
=====================================================================
 2023-08-30 16:50:51.997 | 1234567890                               |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq                        |

> select ts,char_length(v1),length(v1) from t2;
           ts            |    char_length(v1)    |      length(v1)       |
==========================================================================
 2023-08-30 16:50:51.997 |                    10 |                    40 |
 2023-08-30 16:51:13.694 |                    17 |                    68 |

> select ts,v2 from t2;
           ts            |                    v2                    |
=====================================================================
 2023-08-30 16:50:51.997 | 1234567890                               |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq                        |

> select ts,char_length(v2),length(v2) from t2;
           ts            |    char_length(v2)    |      length(v2)       |
==========================================================================
 2023-08-30 16:50:51.997 |                    10 |                    10 |
 2023-08-30 16:51:13.694 |                    17 |                    17 |
```
|类型|Bytes|说明|
|---|----|----------|
|BINARY|自定义|记录单字节字符串，建议只用于处理 ASCII 可见字符，中文等多字节字符需使用 NCHAR|
|NCHAR|自定义|记录包含多字节字符在内的字符串，如中文字符。每个 NCHAR 字符占用 4 字节的存储空间。|

#### LOWER

```sql
LOWER(expr)
```

**功能说明**：将字符串参数值转换为全小写字母。

**返回结果类型**：与输入字段的原始类型相同。

**适用数据类型**：VARCHAR, NCHAR。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**:
```sql
> select * from t2;
           ts            |                    v1                    |                    v2                    |
================================================================================================================
 2023-08-30 16:50:51.997 | 1234567890                               | 1234567890                               |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq                        | abcdefghijklmnopq                        |
 2023-08-31 08:32:41.830 | ABCDEFGH                                 | IJKLMNO                                  |

> select ts,lower(v1),lower(v2) from t2;
           ts            |                lower(v1)                 |                lower(v2)                 |
================================================================================================================
 2023-08-30 16:50:51.997 | 1234567890                               | 1234567890                               |
 2023-08-30 16:51:13.694 | abcdefghijklmnopq                        | abcdefghijklmnopq                        |
 2023-08-31 08:32:41.830 | abcdefgh                                 | ijklmno                                  |

> select lower('ABCDEFGHIJKLMNO') from t2 limit 1;
 lower('ABCDEFGHIJKLMNO') |
===========================
 abcdefghijklmno          |
```

#### LTRIM

```sql
LTRIM(expr)
```

**功能说明**：返回清除左侧开头空格后的字符串。

**返回结果类型**：与输入字段的原始类型相同。

**适用数据类型**：VARCHAR, NCHAR。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**:
```sql
> insert into t2 values(now,' abc def gh','ABC def GH ');
> select * from t2;
           ts            |                    v1                    |                    v2                    |
================================================================================================================
 2023-08-31 08:32:41.830 | ABCDEFGH                                 | IJKLMNO                                  |
 2023-08-31 08:35:45.209 | abc def gh                               | ABC DEF                                  |
 2023-08-31 08:40:33.666 |  abc def gh                              | ABC def GH                               |

> select ts,ltrim(v1),ltrim(v2) from t2;
           ts            |                ltrim(v1)                 |                ltrim(v2)                 |
================================================================================================================
 2023-08-31 08:32:41.830 | ABCDEFGH                                 | IJKLMNO                                  |
 2023-08-31 08:35:45.209 | abc def gh                               | ABC DEF                                  |
 2023-08-31 08:40:33.666 | abc def gh                               | ABC def GH                               |

> select concat('|',ltrim(' abcdef '),'|') from t2 limit 1;
 concat('|',ltrim(' abcdef '),'|') |
====================================
 |abcdef |                         |
```

#### RTRIM

```sql
RTRIM(expr)
```

**功能说明**：返回清除右侧结尾空格后的字符串。

**返回结果类型**：与输入字段的原始类型相同。

**适用数据类型**：VARCHAR, NCHAR。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**：
```sql
> insert into t2 values(now,' abc def gh','ABC def GH ');
> select * from t2;
           ts            |                    v1                    |                    v2                    |
================================================================================================================
 2023-08-31 08:32:41.830 | ABCDEFGH                                 | IJKLMNO                                  |
 2023-08-31 08:35:45.209 | abc def gh                               | ABC DEF                                  |
 2023-08-31 08:40:33.666 |  abc def gh                              | ABC def GH                               |

> select ts,rtrim(v1),rtrim(v2) from t2;
           ts            |                rtrim(v1)                 |                rtrim(v2)                 |
================================================================================================================
 2023-08-31 08:32:41.830 | ABCDEFGH                                 | IJKLMNO                                  |
 2023-08-31 08:35:45.209 | abc def gh                               | ABC DEF                                  |
 2023-08-31 08:40:33.666 |  abc def gh                              | ABC def GH                               | 

> select concat('|',rtrim(' abcdef '),'|') from t2 limit 1;
 concat('|',rtrim(' abcdef '),'|') |
====================================
 | abcdef|                         |
```


#### SUBSTR

```sql
SUBSTR(expr, pos [,len])
```

**功能说明**：从源字符串 str 中的指定位置 pos 开始取一个长度为 len 的子串并返回。如果输入参数 len 被忽略，返回的子串包含从 pos 开始的整个字串。

**返回结果类型**：与输入字段的原始类型相同。

**适用数据类型**：VARCHAR, NCHAR。输入参数 pos 可以为正数，也可以为负数。如果 pos 是正数，表示开始位置从字符串开头正数计算。如果 pos 为负数，表示开始位置从字符串结尾倒数计算。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**：
```sql
> desc t2;
                  field                   |          type          |   length    |    note    |
===============================================================================================
 ts                                       | TIMESTAMP              |           8 |            |
 v1                                       | NCHAR                  |         100 |            |
 v2                                       | VARCHAR                |         100 |            |

> select * from t2;
           ts            |                    v1                    |                    v2                    |
================================================================================================================
 2023-08-31 08:49:15.674 | a1234567890                              | a1234567890                              |

> select ts,substr(v1,2),substr(v1,2,2) from t2;
           ts            |               substr(v1,2)               |              substr(v1,2,2)              |
================================================================================================================
 2023-08-31 08:49:15.674 | 1234567890                               | 12                                       |

> select ts,substr(v1,2),substr(v1,2,2) from (select * from t2);
           ts            |               substr(v1,2)               |              substr(v1,2,2)              |
================================================================================================================
 2023-08-31 08:49:15.674 | 1234567890                               | 12                                       |

> select substr('asdfghjkl',3,1) from t2 limit 1;
 substr('asdfghjkl',3,1) |
==========================
 d                       |
```

#### UPPER

```sql
UPPER(expr)
```

**功能说明**：将字符串参数值转换为全大写字母。

**返回结果类型**：与输入字段的原始类型相同。

**适用数据类型**：VARCHAR, NCHAR。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**:
```sql
> select * from t2;
           ts            |                    v1                    |                    v2                    |
================================================================================================================
 2023-08-31 08:49:15.674 | a1234567890                              | a1234567890                              |
 2023-08-31 08:52:41.118 | abcdef                                   | Ghijk                                    |

> select ts,upper(v1),upper(v2) from t2;
           ts            |                upper(v1)                 |                upper(v2)                 |
================================================================================================================
 2023-08-31 08:49:15.674 | A1234567890                              | A1234567890                              |
 2023-08-31 08:52:41.118 | ABCDEF                                   | GHIJK                                    |

> select ts,upper(v1),upper(v2) from (select * from t2);
           ts            |                upper(v1)                 |                upper(v2)                 |
================================================================================================================
 2023-08-31 08:49:15.674 | A1234567890                              | A1234567890                              |
 2023-08-31 08:52:41.118 | ABCDEF                                   | GHIJK                                    |

> select upper('abcDEFghi') from t2 limit 1;
 upper('abcDEFghi') |
=====================
 ABCDEFGHI          |
```


### 转换函数

转换函数将值从一种数据类型转换为另一种数据类型。

#### CAST

```sql
CAST(expr AS type_name)
```

**功能说明**：数据类型转换函数，返回 expr 转换为 type_name 指定的类型后的结果。只适用于 select 子句中。

**返回结果类型**：CAST 中指定的类型（type_name)。

**适用数据类型**：输入参数 expression 的类型可以是除JSON外的所有类型。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：

- 对于不能支持的类型转换会直接报错。
- 对于类型支持但某些值无法正确转换的情况，对应的转换后的值以转换函数输出为准。目前可能遇到的几种情况：
        1）字符串类型转换数值类型时可能出现的无效字符情况，例如"a"可能转为0，但不会报错。
        2）转换到数值类型时，数值大于type_name可表示的范围时，则会溢出，但不会报错。
        3）转换到字符串类型时，如果转换后长度超过type_name中指定的长度，则会截断，但不会报错。

**示例**:
```sql
> desc t3;
                  field                   |          type          |   length    |    note    |
===============================================================================================
 ts                                       | TIMESTAMP              |           8 |            |
 v1                                       | INT                    |           4 |            |
 v2                                       | FLOAT                  |           4 |            |
 v3                                       | DOUBLE                 |           8 |            |
 v4                                       | NCHAR                  |         100 |            |

> select * from t3;
           ts            |     v1      |          v2          |            v3             |                    v4                    |
======================================================================================================================================
 2023-08-31 08:56:14.567 |           1 |            2.2000000 |         3.333333333333000 | ABCDEFG                                  |

> select ts,cast(v1 as float) from t3;
           ts            |  cast(v1 as float)   |
=================================================
 2023-08-31 08:56:14.567 |            1.0000000 |

> select ts,cast(v3 as float) from t3;
           ts            |  cast(v3 as float)   |
=================================================
 2023-08-31 08:56:14.567 |            3.3333333 |

> select ts,cast(v4 as float) from t3;
           ts            |  cast(v4 as float)   |
=================================================
 2023-08-31 08:56:14.567 |            0.0000000 |

taos> select ts,cast(v4 as binary) from t3;

> select ts,cast(v4 as binary(100)) from t3;
           ts            |         cast(v4 as binary(100))          |
=====================================================================
 2023-08-31 08:56:14.567 | ABCDEFG                                  |

> select ts,cast(v1 as binary(100)) from t3;
           ts            |         cast(v1 as binary(100))          |
=====================================================================
 2023-08-31 08:56:14.567 | 1                                        |

> select ts,cast(v2 as binary(100)) from t3;
           ts            |         cast(v2 as binary(100))          |
=====================================================================
 2023-08-31 08:56:14.567 | 2.200000                                 |

> select ts,cast(v3 as binary(100)) from t3;
           ts            |         cast(v3 as binary(100))          |
=====================================================================
 2023-08-31 08:56:14.567 | 3.333333                                 |

> select ts,cast(v3 as binary(2)) from t3;
           ts            | cast(v3 as binary(2)) |
==================================================
 2023-08-31 08:56:14.567 | 3.                    |

> select ts,cast(v4 as binary(2)) from t3;
           ts            | cast(v4 as binary(2)) |
==================================================
 2023-08-31 08:56:14.567 | AB                    |
```

#### TO_ISO8601

```sql
TO_ISO8601(expr [, timezone])
```

**功能说明**：将 UNIX 时间戳转换成为 ISO8601 标准的日期时间格式，并附加时区信息。timezone 参数允许用户为输出结果指定附带任意时区信息。如果 timezone 参数省略，输出结果则附带当前客户端的系统时区信息。

**返回结果数据类型**：VARCHAR 类型。

**适用数据类型**：INTEGER, TIMESTAMP。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**使用说明**：

- timezone 参数允许输入的时区格式为: [z/Z, +/-hhmm, +/-hh, +/-hh:mm]。例如，TO_ISO8601(1, "+00:00")。
- 如果输入是表示 UNIX 时间戳的整形，返回格式精度由时间戳的位数决定;
- 如果输入是 TIMESTAMP 类型的列，返回格式的时间戳精度与当前 DATABASE 设置的时间精度一致。
- 如果输入的是 ISO8601 类型，返回时间不会转换，只会在后面添加 TIMEZONE。

**示例**: 见 to_unixtimestamp

#### TO_UNIXTIMESTAMP

```sql
TO_UNIXTIMESTAMP(expr [, return_timestamp])

return_timestamp: {
    0
  | 1
}
```

**功能说明**：将日期时间格式的字符串转换成为 UNIX 时间戳。

**返回结果数据类型**：BIGINT, TIMESTAMP。

**应用字段**：VARCHAR, NCHAR。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**：表和超级表。

**使用说明**：

- 输入的日期时间字符串须符合 ISO8601/RFC3339 标准，无法转换的字符串格式将返回 NULL。
- 返回的时间戳精度与当前 DATABASE 设置的时间精度一致。
- return_timestamp 指定函数返回值是否为时间戳类型，设置为1时返回 TIMESTAMP 类型，设置为0时返回 BIGINT 类型。如不指定缺省返回 BIGINT 类型。
- restur_timestamp 为 0 时，返回的时间默认为已当前系统配置时区。

**示例**:
```sql
> show variables;
               name               |                  value                   |  scope   |
=========================================================================================
 statusInterval                   | 1                                        | server   |
 timezone                         | Asia/Shanghai (CST, +0800)               | both     |
 locale                           | en_US.UTF-8                              | both     |
 charset                          | UTF-8                                    | both     |

> select ts from t3;
           ts            |
==========================
 2023-08-31 08:56:14.567 |

> select to_iso8601(ts) from t3;
              to_iso8601(ts)              |
===========================================
 2023-08-31T08:56:14.567+0800             |

> select to_iso8601(ts,'+00:00') from t3;
         to_iso8601(ts,'+00:00')          |
===========================================
 2023-08-31T08:56:14.567+00:00            |

> select to_unixtimestamp(to_iso8601(ts)) from t3;
 to_unixtimestamp(to_iso8601(ts)) |
===================================
                    1693443374567 |

> select to_unixtimestamp(to_iso8601(ts,'+00:00')) from t3;
 to_unixtimestamp(to_iso8601(ts,'+00:00')) |
============================================
                             1693472174567 |

> select to_iso8601(to_unixtimestamp(to_iso8601(ts,'+00:00'))) from t3;
 to_iso8601(to_unixtimestamp(to_iso8601(ts,'+00:00'))) |
========================================================
 2023-08-31T16:56:14.567+0800                          |

> select to_unixtimestamp(to_iso8601(ts,'+00:00'),0) from t3;
 to_unixtimestamp(to_iso8601(ts,'+00:00'),0) |
==============================================
                               1693472174567 |

> select to_unixtimestamp(to_iso8601(ts,'+00:00'),1) from t3;
 to_unixtimestamp(to_iso8601(ts,'+00:00'),1) |
==============================================
 2023-08-31 16:56:14.567 |
```

#### TO_JSON

```sql
TO_JSON(str_literal)
```

**功能说明**: 将字符串常量转换为 JSON 类型。

**返回结果数据类型**: JSON。

**适用数据类型**: JSON 字符串，形如 '{ "literal" : literal }'。'{}'表示空值。键必须为字符串字面量，值可以为数值字面量、字符串字面量、布尔字面量或空值字面量。str_literal中不支持转义符。

**嵌套子查询支持**：适用于内层查询和外层查询。

**适用于**: 表和超级表。

**示例**：
```sql
> select ts, to_json('{"values":100,"tag":"voltage"}') from t3;
           ts            | to_json('{"values":100,"tag":"voltage"}') |
======================================================================
 2023-08-31 08:56:14.567 | {"tag":"voltage","values":100}            |
```


### 时间和日期函数

时间和日期函数对时间戳类型进行操作。

所有返回当前时间的函数，如NOW、TODAY和TIMEZONE，在一条SQL语句中不论出现多少次都只会被计算一次。

#### NOW

```sql
NOW()
```

**功能说明**：返回客户端当前系统时间。

**返回结果数据类型**：TIMESTAMP。

**应用字段**：在 WHERE 或 INSERT 语句中使用时只能作用于 TIMESTAMP 类型的字段。

**适用于**：表和超级表。

**嵌套子查询支持**：适用于内层查询和外层查询。

**使用说明**：

- 支持时间加减操作，如 NOW() + 1s, 支持的时间单位如下：
        b(纳秒)、u(微秒)、a(毫秒)、s(秒)、m(分)、h(小时)、d(天)、w(周)。
- 返回的时间戳精度与当前 DATABASE 设置的时间精度一致。

**示例**:
```sql
> create table t4 (ts timestamp, v1 int);
> insert into t4 values(now,1);
> insert into t4 values(now,2);
> insert into t4 values(now,3);

> select * from t4;
           ts            |     v1      |
========================================
 2023-08-31 09:27:36.033 |           1 |
 2023-08-31 09:27:38.275 |           2 |
 2023-08-31 09:27:40.270 |           3 |

> select * from t4 where ts>now-60s;
           ts            |     v1      |
========================================
 2023-08-31 09:27:36.033 |           1 |
 2023-08-31 09:27:38.275 |           2 |
 2023-08-31 09:27:40.270 |           3 |
```

#### TIMEDIFF

```sql
TIMEDIFF(expr1, expr2 [, time_unit])
```

**功能说明**：计算两个时间戳之间的差值，并近似到时间单位 time_unit 指定的精度。

**返回结果数据类型**：BIGINT。

**应用字段**：表示 UNIX 时间戳的 BIGINT, TIMESTAMP 类型，或符合日期时间格式的 VARCHAR, NCHAR 类型。

**适用于**：表和超级表。

**嵌套子查询支持**：适用于内层查询和外层查询。

**使用说明**：
- 支持的时间单位 time_unit 如下(时间精度不能小于 DATABASE 时间精度)：
          1b(纳秒), 1u(微秒)，1a(毫秒)，1s(秒)，1m(分)，1h(小时)，1d(天), 1w(周)。
- 如果时间单位 time_unit 未指定， 返回的时间差值精度与当前 DATABASE 设置的时间精度一致。
- 输入包含不符合时间日期格式的字符串则返回 NULL。

**示例**:
```sql
> create table t5 (ts1 timestamp,ts2 timestamp);
> insert into t5 values(now,now-1s);
> insert into t5 values(now,now-2s);
> insert into t5 values(now,now-3s);

taos> select * from t5;
           ts1           |           ts2           |
====================================================
 2023-08-31 09:32:54.649 | 2023-08-31 09:32:53.649 |
 2023-08-31 09:32:57.637 | 2023-08-31 09:32:55.637 |
 2023-08-31 09:32:59.935 | 2023-08-31 09:32:56.935 |

> select timediff(ts1,ts2) from t5;
   timediff(ts1,ts2)   |
========================
                  1000 |
                  2000 |
                  3000 |

> select timediff(ts1,ts2,1s) from t5;
 timediff(ts1,ts2,1s)  |
========================
                     1 |
                     2 |
                     3 |

> select timediff(ts1,ts2,1m) from t5;
 timediff(ts1,ts2,1m)  |
========================
                     0 |
                     0 |
                     0 |

> select timediff(ts1,ts2,1u) from t5;

DB error: TIMEDIFF function time unit parameter should be greater than db precision (0.000294s)
```

#### TIMETRUNCATE

```sql
TIMETRUNCATE(expr, time_unit [, ignore_timezone])

ignore_timezone: {
    0
  | 1
}
```

**功能说明**：将时间戳按照指定时间单位 time_unit 进行截断。

**返回结果数据类型**：TIMESTAMP。

**应用字段**：表示 UNIX 时间戳的 BIGINT, TIMESTAMP 类型，或符合日期时间格式的 VARCHAR, NCHAR 类型。

**适用于**：表和超级表。

**使用说明**：
- 支持的时间单位 time_unit 如下：
          1b(纳秒), 1u(微秒)，1a(毫秒)，1s(秒)，1m(分)，1h(小时)，1d(天), 1w(周)。
- 返回的时间戳精度与当前 DATABASE 设置的时间精度一致。
- 输入包含不符合时间日期格式的字符串则返回 NULL。
- 当使用 1d 作为时间单位对时间戳进行截断时， 可通过设置 ignore_timezone 参数指定返回结果的显示是否忽略客户端时区的影响。
  例如客户端所配置时区为 UTC+0800, 则 TIMETRUNCATE('2020-01-01 23:00:00', 1d, 0) 返回结果为 '2020-01-01 08:00:00'。
  而使用 TIMETRUNCATE('2020-01-01 23:00:00', 1d, 1) 设置忽略时区时，返回结果为 '2020-01-01 00:00:00'
  ignore_timezone 如果忽略的话，则默认值为 1 。

**示例**:
```sql
> select ts1 from t5;
           ts1           |
==========================
 2023-08-31 09:32:54.649 |
 2023-08-31 09:32:57.637 |
 2023-08-31 09:32:59.935 |

> select timetruncate(ts1,1s) from t5;
  timetruncate(ts1,1s)   |
==========================
 2023-08-31 09:32:54.000 |
 2023-08-31 09:32:57.000 |
 2023-08-31 09:32:59.000 |

> select timetruncate(ts1,1m) from t5;
  timetruncate(ts1,1m)   |
==========================
 2023-08-31 09:32:00.000 |
 2023-08-31 09:32:00.000 |
 2023-08-31 09:32:00.000 |

> select timetruncate(ts1,1h) from t5;
  timetruncate(ts1,1h)   |
==========================
 2023-08-31 09:00:00.000 |
 2023-08-31 09:00:00.000 |
 2023-08-31 09:00:00.000 |

> select timetruncate(ts1,1d) from t5;
  timetruncate(ts1,1d)   |
==========================
 2023-08-31 00:00:00.000 |
 2023-08-31 00:00:00.000 |
 2023-08-31 00:00:00.000 |

> select timetruncate(ts1,1d,0) from t5;
 timetruncate(ts1,1d,0)  |
==========================
 2023-08-31 08:00:00.000 |
 2023-08-31 08:00:00.000 |
 2023-08-31 08:00:00.000 |

> select timetruncate(ts1,1d,1) from t5;
 timetruncate(ts1,1d,1)  |
==========================
 2023-08-31 00:00:00.000 |
 2023-08-31 00:00:00.000 |
 2023-08-31 00:00:00.000 |

> select timetruncate('2023-01-01T12:01:00+09:00',1h,1) from t5;
 timetruncate('2023-01-01T12:01:00+09:00',1h,1) |
=================================================
 2023-01-01 11:00:00.000 |
 2023-01-01 11:00:00.000 |
 2023-01-01 11:00:00.000 |

> select timetruncate('2023-01-01T12:01:00+09:00',1h,0) from t5;
 timetruncate('2023-01-01T12:01:00+09:00',1h,0) |
=================================================
 2023-01-01 11:00:00.000 |
 2023-01-01 11:00:00.000 |
 2023-01-01 11:00:00.000 |

```

#### TIMEZONE

```sql
TIMEZONE()
```

**功能说明**：返回客户端当前时区信息。

**返回结果数据类型**：VARCHAR。

**应用字段**：无

**适用于**：表和超级表。

**示例**:
```sql
> show variables;
               name               |                  value                   |  scope   |
=========================================================================================
 statusInterval                   | 1                                        | server   |
 timezone                         | Asia/Shanghai (CST, +0800)               | both     |
 locale                           | en_US.UTF-8                              | both     |
 charset                          | UTF-8                                    | both     |

> select timezone() from t5 limit 1;
                timezone()                |
===========================================
 Asia/Shanghai (CST, +0800)               |
```

#### TODAY

```sql
TODAY()
```

**功能说明**：返回客户端当日零时的系统时间。

**返回结果数据类型**：TIMESTAMP。

**应用字段**：在 WHERE 或 INSERT 语句中使用时只能作用于 TIMESTAMP 类型的字段。

**适用于**：表和超级表。

**使用说明**：

- 支持时间加减操作，如 TODAY() + 1s, 支持的时间单位如下：
                b(纳秒)，u(微秒)，a(毫秒)，s(秒)，m(分)，h(小时)，d(天)，w(周)。
- 返回的时间戳精度与当前 DATABASE 设置的时间精度一致。

**示例**:
```sql
> select today() from t5 limit 1;
         today()         |
==========================
 2023-08-31 00:00:00.000 |

> select today()+1h from t5 limit 1;
       today()+1h        |
==========================
 2023-08-31 01:00:00.000 |

> select today(),now from t5 limit 1;
         today()         |           now           |
====================================================
 2023-08-31 00:00:00.000 | 2023-08-31 09:44:40.058 |
```


## 聚合函数

聚合函数为查询结果集的每一个分组返回单个结果行。可以由 GROUP BY 或窗口切分子句指定分组，如果没有，则整个查询结果集视为一个分组。

TDengine 支持针对数据的聚合查询。提供如下聚合函数。

### APERCENTILE

```sql
APERCENTILE(expr, p [, algo_type])

algo_type: {
    "default"
  | "t-digest"
}
```

**功能说明**：统计表/超级表中指定列的值的近似百分比分位数，与 PERCENTILE 函数相似，但是返回近似结果。

**返回数据类型**： DOUBLE。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**说明**：
- p值范围是[0,100]，当为0时等同于MIN，为100时等同于MAX。
- algo_type 取值为 "default" 或 "t-digest"。 输入为 "default" 时函数使用基于直方图算法进行计算。输入为 "t-digest" 时使用t-digest算法计算分位数的近似结果。如果不指定 algo_type 则使用 "default" 算法。
- "t-digest"算法的近似结果对于输入数据顺序敏感，对超级表查询时不同的输入排序结果可能会有微小的误差。

**示例**:
```sql
> select * from t6;
           ts            |     v1      |
========================================
 2023-08-31 09:46:31.582 |           1 |
 2023-08-31 09:46:33.366 |           2 |
 2023-08-31 09:46:35.271 |           3 |
 2023-08-31 09:46:37.699 |           4 |
 2023-08-31 09:46:39.562 |           5 |
 2023-08-31 09:46:41.868 |           6 |
 2023-08-31 09:46:44.229 |           7 |
 2023-08-31 09:46:46.365 |           8 |
 2023-08-31 09:46:48.345 |           9 |
 2023-08-31 09:46:50.451 |          10 |

> select apercentile(v1,10) from t6;
    apercentile(v1,10)     |
============================
         1.000000000000000 |

> select apercentile(v1,20) from t6;
    apercentile(v1,20)     |
============================
         2.000000000000000 |

> select apercentile(v1,90) from t6;
    apercentile(v1,90)     |
============================
         9.000000000000000 |

> select apercentile(v1,90,"t-digest") from t6;
 apercentile(v1,90,"t-digest") |
================================
         9.500000000000000e+00 |

```

### AVG

```sql
AVG(expr)
```

**功能说明**：统计指定字段的平均值。

**返回数据类型**：DOUBLE。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**示例**:
```sql
> select * from t6;
           ts            |     v1      |
========================================
 2023-08-31 09:46:31.582 |           1 |
 2023-08-31 09:46:33.366 |           2 |
 2023-08-31 09:46:35.271 |           3 |
 2023-08-31 09:46:37.699 |           4 |
 2023-08-31 09:46:39.562 |           5 |
 2023-08-31 09:46:41.868 |           6 |
 2023-08-31 09:46:44.229 |           7 |
 2023-08-31 09:46:46.365 |           8 |
 2023-08-31 09:46:48.345 |           9 |
 2023-08-31 09:46:50.451 |          10 |

> select avg(v1) from t6;
          avg(v1)          |
============================
         5.500000000000000 |
```

### COUNT

```sql
COUNT({* | expr})
```

**功能说明**：统计指定字段的记录行数。

**返回数据类型**：BIGINT。

**适用数据类型**：全部类型字段。

**适用于**：表和超级表。

**使用说明**:

- 可以使用星号(\*)来替代具体的字段，使用星号(\*)返回全部记录数量。
- 如果统计字段是具体的列，则返回该列中非 NULL 值的记录数量。

**示例**:
```sql
> select * from t6;
           ts            |     v1      |
========================================
 2023-08-31 09:46:31.582 |           1 |
 2023-08-31 09:46:33.366 |           2 |
 2023-08-31 09:46:35.271 |           3 |
 2023-08-31 09:46:37.699 |           4 |
 2023-08-31 09:46:39.562 |           5 |
 2023-08-31 09:46:41.868 |           6 |
 2023-08-31 09:46:44.229 |           7 |
 2023-08-31 09:46:46.365 |           8 |
 2023-08-31 09:46:48.345 |           9 |
 2023-08-31 09:46:50.451 |          10 |

> select count(*) from t6;
       count(*)        |
========================
                    10 |

> select count(v1) from t6;
       count(v1)       |
========================
                    10 |

> select count(*) from (select count(v1) from t6);
       count(*)        |
========================
                     1 |
```

### ELAPSED

```sql
ELAPSED(ts_primary_key [, time_unit])
```

**功能说明**：elapsed函数表达了统计周期内连续的时间长度，和twa函数配合使用可以计算统计曲线下的面积。在通过INTERVAL子句指定窗口的情况下，统计在给定时间范围内的每个窗口内有数据覆盖的时间范围；如果没有INTERVAL子句，则返回整个给定时间范围内的有数据覆盖的时间范围。注意，ELAPSED返回的并不是时间范围的绝对值，而是绝对值除以time_unit所得到的单位个数。

**返回结果类型**：DOUBLE。

**适用数据类型**：TIMESTAMP。

**适用于**: 表，超级表，嵌套查询的外层查询

**说明**：
- ts_primary_key参数只能是表的第一列，即 TIMESTAMP 类型的主键列。
- 按time_unit参数指定的时间单位返回，最小是数据库的时间分辨率。time_unit 参数未指定时，以数据库的时间分辨率为时间单位。支持的时间单位 time_unit 如下：
          1b(纳秒), 1u(微秒)，1a(毫秒)，1s(秒)，1m(分)，1h(小时)，1d(天), 1w(周)。
- 可以和interval组合使用，返回每个时间窗口的时间戳差值。需要特别注意的是，除第一个时间窗口和最后一个时间窗口外，中间窗口的时间戳差值均为窗口长度。
- order by asc/desc不影响差值的计算结果。
- 对于超级表，需要和group by tbname子句组合使用，不可以直接使用。
- 对于普通表，不支持和group by子句组合使用。
- 对于嵌套查询，仅当内层查询会输出隐式时间戳列时有效。例如select elapsed(ts) from (select diff(value) from sub1)语句，diff函数会让内层查询输出隐式时间戳列，此为主键列，可以用于elapsed函数的第一个参数。相反，例如select elapsed(ts) from (select * from sub1) 语句，ts列输出到外层时已经没有了主键列的含义，无法使用elapsed函数。此外，elapsed函数作为一个与时间线强依赖的函数，形如select elapsed(ts) from (select diff(value) from st group by tbname)尽管会返回一条计算结果，但并无实际意义，这种用法后续也将被限制。
- 不支持与leastsquares、diff、derivative、top、bottom、last_row、interp等函数混合使用。

**示例**:
```sql
> select * from t6;
           ts            |     v1      |
========================================
 2023-08-31 09:46:31.582 |           1 |
 2023-08-31 09:46:33.366 |           2 |
 2023-08-31 09:46:35.271 |           3 |
 2023-08-31 09:46:37.699 |           4 |
 2023-08-31 09:46:39.562 |           5 |
 2023-08-31 09:46:41.868 |           6 |
 2023-08-31 09:46:44.229 |           7 |
 2023-08-31 09:46:46.365 |           8 |
 2023-08-31 09:46:48.345 |           9 |
 2023-08-31 09:46:50.451 |          10 |

> select elapsed(ts) from t6;
        elapsed(ts)        |
============================
     18869.000000000000000 |

> select elapsed(ts,1s) from t6;
      elapsed(ts,1s)       |
============================
        18.869000000000000 |

> select elapsed(ts,1m) from t6;
      elapsed(ts,1m)       |
============================
         0.314483333333333 |

> select elapsed(ts,1h) from t6;
      elapsed(ts,1h)       |
============================
         0.005241388888889 |

> select elapsed(ts,1u) from t6;

DB error: ELAPSED function time unit parameter should be greater than db precision (0.000691s)

> select _wstart,_wend,elapsed(ts,1a) from t6 interval(1s);
         _wstart         |          _wend          |      elapsed(ts,1a)       |
================================================================================
 2023-08-31 09:46:31.000 | 2023-08-31 09:46:32.000 |       418.000000000000000 |
 2023-08-31 09:46:33.000 | 2023-08-31 09:46:34.000 |      1000.000000000000000 |
 2023-08-31 09:46:35.000 | 2023-08-31 09:46:36.000 |      1000.000000000000000 |
 2023-08-31 09:46:37.000 | 2023-08-31 09:46:38.000 |      1000.000000000000000 |
 2023-08-31 09:46:39.000 | 2023-08-31 09:46:40.000 |      1000.000000000000000 |
 2023-08-31 09:46:41.000 | 2023-08-31 09:46:42.000 |      1000.000000000000000 |
 2023-08-31 09:46:44.000 | 2023-08-31 09:46:45.000 |      1000.000000000000000 |
 2023-08-31 09:46:46.000 | 2023-08-31 09:46:47.000 |      1000.000000000000000 |
 2023-08-31 09:46:48.000 | 2023-08-31 09:46:49.000 |      1000.000000000000000 |
 2023-08-31 09:46:50.000 | 2023-08-31 09:46:51.000 |       451.000000000000000 |

```

### LEASTSQUARES

```sql
LEASTSQUARES(expr, start_val, step_val)
```

**功能说明**：统计表中某列的值是主键（时间戳）的拟合直线方程。start_val 是自变量初始值，step_val 是自变量的步长值。

**返回数据类型**：字符串表达式（斜率, 截距）。

**适用数据类型**：expr 必须是数值类型。

**适用于**：表。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |

> select leastsquares(v1,0,1) from t7;
           leastsquares(v1,0,1)           |
===========================================
 {slop:1.000000, intercept:1.000000}      |

> select leastsquares(v1,0,2) from t7;
           leastsquares(v1,0,2)           |
===========================================
 {slop:0.500000, intercept:1.000000}      |

> select leastsquares(v1,0,5) from t7;
           leastsquares(v1,0,5)           |
===========================================
 {slop:0.200000, intercept:1.000000}      |
```

### SPREAD

```sql
SPREAD(expr)
```

**功能说明**：统计表中某列的最大值和最小值之差。

**返回数据类型**：DOUBLE。

**适用数据类型**：INTEGER, TIMESTAMP。

**适用于**：表和超级表。

**示例**:
```sql
select * from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |

> select spread(ts),spread(v1) from t7;
        spread(ts)         |        spread(v1)         |
========================================================
      8000.000000000000000 |         8.000000000000000 |
```

### STDDEV

```sql
STDDEV(expr)
```

**功能说明**：统计表中某列的均方差。

**返回数据类型**：DOUBLE。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |

> select stddev(v1) from t7;
        stddev(v1)         |
============================
         2.581988897471612 |
```

### SUM

```sql
SUM(expr)
```

**功能说明**：统计表/超级表中某列的和。

**返回数据类型**：DOUBLE, BIGINT。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |

> select sum(v1) from t7;
        sum(v1)        |
========================
                    45 |
```

### HYPERLOGLOG

```sql
HYPERLOGLOG(expr)
```

**功能说明**：
  - 采用 hyperloglog 算法，返回某列的基数。该算法在数据量很大的情况下，可以明显降低内存的占用，求出来的基数是个估算值，标准误差（标准误差是多次实验，每次的平均数的标准差，不是与真实结果的误差）为 0.81%。
  - 在数据量较少的时候该算法不是很准确，可以使用 select count(data) from (select unique(col) as data from table) 的方法。

**返回结果类型**：INTEGER。

**适用数据类型**：任何类型。

**适用于**：表和超级表。

**示例**:
```sql
> select count(*) from meters;
       count(*)        |
========================
             109847142 |

> select hyperloglog(current) from meters;
 hyperloglog(current)  |
========================
                  1003 |

> select count(*) from (select unique(current) from meters);
       count(*)        |
========================
                  1009 |

> select hyperloglog(voltage) from meters;
 hyperloglog(voltage)  |
========================
                  1001 |

> select count(*) from (select unique(voltage) from meters);
       count(*)        |
========================
                  1000 |
```

### HISTOGRAM

```sql
HISTOGRAM(expr，bin_type, bin_description, normalized)
```

**功能说明**：统计数据按照用户指定区间的分布。

**返回结果类型**：如归一化参数 normalized 设置为 1，返回结果为 DOUBLE 类型，否则为 BIGINT 类型。

**适用数据类型**：数值型字段。

**适用于**: 表和超级表。

**详细说明**：
- bin_type 用户指定的分桶类型, 有效输入类型为"user_input“, ”linear_bin", "log_bin"。
- bin_description 描述如何生成分桶区间，针对三种桶类型，分别为以下描述格式(均为 JSON 格式字符串)：
    - "user_input": "[1, 3, 5, 7]"
       用户指定 bin 的具体数值。

    - "linear_bin": "{"start": 0.0, "width": 5.0, "count": 5, "infinity": true}"
       "start" 表示数据起始点，"width" 表示每次 bin 偏移量, "count" 为 bin 的总数，"infinity" 表示是否添加（-inf, inf）作为区间起点和终点，
       生成区间为[-inf, 0.0, 5.0, 10.0, 15.0, 20.0, +inf]。

    - "log_bin": "{"start":1.0, "factor": 2.0, "count": 5, "infinity": true}"
       "start" 表示数据起始点，"factor" 表示按指数递增的因子，"count" 为 bin 的总数，"infinity" 表示是否添加（-inf, inf）作为区间起点和终点，
       生成区间为[-inf, 1.0, 2.0, 4.0, 8.0, 16.0, +inf]。
- normalized 是否将返回结果归一化到 0~1 之间 。有效输入为 0 和 1。

**示例**:
```sql

```

### PERCENTILE

```sql
PERCENTILE(expr, p [, p1] ... )
```

**功能说明**：统计表中某列的值百分比分位数。

**返回数据类型**： 该函数最小参数个数为 2 个，最大参数个数为 11 个。可以最多同时返回 10 个百分比分位数。当参数个数为 2 时， 返回一个分位数， 类型为DOUBLE，当参数个数大于 2 时，返回类型为VARCHAR, 格式为包含多个返回值的JSON数组。

**应用字段**：数值类型。

**适用于**：表。

**使用说明**：

- *P*值取值范围 0≤*P*≤100，为 0 的时候等同于 MIN，为 100 的时候等同于 MAX;
- 同时计算针对同一列的多个分位数时，建议使用一个PERCENTILE函数和多个参数的方式，能很大程度上降低查询的响应时间。
  比如，使用查询SELECT percentile(col, 90, 95, 99) FROM table, 性能会优于SELECT percentile(col, 90), percentile(col, 95), percentile(col, 99) from table。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |

> select percentile(v1,10,20,50,80) from t7;
        percentile(v1,10,20,50,80)        |
===========================================
 [1.900000, 2.800000, 5.500000, 8.200000] |
```

## 选择函数

选择函数根据语义在查询结果集中选择一行或多行结果返回。用户可以同时指定输出 ts 列或其他列（包括 tbname 和标签列），这样就可以方便地知道被选出的值是源于哪个数据行的。

### BOTTOM

```sql
BOTTOM(expr, k)
```

**功能说明**：统计表/超级表中某列的值最小 k 个非 NULL 值。如果多条数据取值一样，全部取用又会超出 k 条限制时，系统会从相同值中随机选取符合要求的数量返回。

**返回数据类型**：同应用的字段。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**使用说明**:

- *k*值取值范围 1≤*k*≤100；
- 限制：BOTTOM 函数不支持 FILL 子句。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |

> select bottom(v1,2) from t7;
 bottom(v1,2) |
===============
            2 |
            1 |

> select ts,bottom(v1,2) from t7;
           ts            | bottom(v1,2) |
=========================================
 2023-08-01 01:01:02.000 |            2 |
 2023-08-01 01:01:01.000 |            1 |

> select ts,bottom(v1,3) from t7;
           ts            | bottom(v1,3) |
=========================================
 2023-08-01 01:01:03.000 |            3 |
 2023-08-01 01:01:01.000 |            1 |
 2023-08-01 01:01:02.000 |            2 |
```

### FIRST

```sql
FIRST(expr)
```

**功能说明**：统计表/超级表中某列的值最先写入的非 NULL 值。

**返回数据类型**：同应用的字段。

**适用数据类型**：所有字段。

**适用于**：表和超级表。

**使用说明**:

- 如果要返回各个列的首个（时间戳最小）非 NULL 值，可以使用 FIRST(\*)；
- 如果结果集中的某列全部为 NULL 值，则该列的返回结果也是 NULL；
- 如果结果集中所有列全部为 NULL 值，则不返回结果。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |     v2      |
======================================================
 2023-08-01 01:01:00.000 | NULL        | NULL        |
 2023-08-01 01:01:01.000 |           1 | NULL        |
 2023-08-01 01:01:02.000 |           2 | NULL        |
 2023-08-01 01:01:03.000 |           3 | NULL        |
 2023-08-01 01:01:04.000 |           4 | NULL        |
 2023-08-01 01:01:05.000 |           5 | NULL        |
 2023-08-01 01:01:06.000 |           6 | NULL        |
 2023-08-01 01:01:07.000 |           7 | NULL        |
 2023-08-01 01:01:08.000 |           8 | NULL        |
 2023-08-01 01:01:09.000 |           9 | NULL        |
 2023-08-01 01:01:10.000 |          10 | NULL        |

> select first(*) from t7;
        first(ts)        |  first(v1)  |  first(v2)  |
======================================================
 2023-08-01 01:01:00.000 |           1 | NULL        |

> select first(v1) from t7;
  first(v1)  |
==============
           1 |

> select ts,first(v1) from t7;
           ts            |  first(v1)  |
========================================
 2023-08-01 01:01:01.000 |           1 |

> select ts,first(v2) from t7;
Query OK, 0 row(s) in set (0.001117s)

```



### INTERP

```sql
INTERP(expr [, ignore_null_values])

ignore_null_values: {
    0
  | 1
}
```

**功能说明**：返回指定时间截面指定列的记录值或插值。ignore_null_values 参数的值可以是 0 或 1，为 1 时表示忽略 NULL 值, 缺省值为0。

**返回数据类型**：同字段类型。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**使用说明**

- INTERP 用于在指定时间断面获取指定列的记录值，如果该时间断面不存在符合条件的行数据，那么会根据 FILL 参数的设定进行插值。
- INTERP 的输入数据为指定列的数据，可以通过条件语句（where 子句）来对原始列数据进行过滤，如果没有指定过滤条件则输入为全部数据。
- INTERP 需要同时与 RANGE，EVERY 和 FILL 关键字一起使用。
- INTERP 的输出时间范围根据 RANGE(timestamp1, timestamp2)字段来指定，需满足 timestamp1 <= timestamp2。其中 timestamp1 为输出时间范围的起始值，即如果 timestamp1 时刻符合插值条件则 timestamp1 为输出的第一条记录，timestamp2 为输出时间范围的结束值，即输出的最后一条记录的 timestamp 不能大于 timestamp2。
- INTERP 根据 EVERY(time_unit) 字段来确定输出时间范围内的结果条数，即从 timestamp1 开始每隔固定长度的时间（time_unit 值）进行插值，time_unit 可取值时间单位：1a(毫秒)，1s(秒)，1m(分)，1h(小时)，1d(天)，1w(周)。例如 EVERY(500a) 将对于指定数据每500毫秒间隔进行一次插值.
- INTERP 根据 FILL 字段来决定在每个符合输出条件的时刻如何进行插值。
- INTERP 可以在 RANGE 字段中只指定唯一的时间戳对单个时间点进行插值，在这种情况下，EVERY 字段可以省略。例如：SELECT INTERP(col) FROM tb RANGE('2023-01-01 00:00:00') FILL(linear).
- INTERP 作用于超级表时, 会将该超级表下的所有子表数据按照主键列排序后进行插值计算，也可以搭配 PARTITION BY tbname 使用，将结果强制规约到单个时间线。
- INTERP 可以与伪列 _irowts 一起使用，返回插值点所对应的时间戳(3.0.2.0版本以后支持)。
- INTERP 可以与伪列 _isfilled 一起使用，显示返回结果是否为原始记录或插值算法产生的数据(3.0.3.0版本以后支持)。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |     v2      |
======================================================
 2023-08-01 01:01:00.000 | NULL        | NULL        |
 2023-08-01 01:01:01.000 |           1 | NULL        |
 2023-08-01 01:01:02.000 |           2 | NULL        |
 2023-08-01 01:01:03.000 |           3 | NULL        |
 2023-08-01 01:01:04.000 |           4 | NULL        |
 2023-08-01 01:01:05.000 |           5 | NULL        |
 2023-08-01 01:01:06.000 |           6 | NULL        |
 2023-08-01 01:01:07.000 |           7 | NULL        |
 2023-08-01 01:01:08.000 |           8 | NULL        |
 2023-08-01 01:01:09.000 |           9 | NULL        |
 2023-08-01 01:01:10.000 |          10 | NULL        |

> select _irowts,interp(v1) from t7 range('2023-08-01 01:01:01.000','2023-08-01 01:01:12.000') every(1s) fill(prev);
         _irowts         | interp(v1)  |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 |          10 |
 2023-08-01 01:01:12.000 |          10 |

> select _irowts,interp(v1) from t7 range('2023-08-01 01:01:01.000','2023-08-01 01:01:12.000') every(1s) fill(next);
         _irowts         | interp(v1)  |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |

> select _irowts,interp(v1) from t7 range('2023-08-01 01:01:01.000','2023-08-01 01:01:12.000') every(1s) fill(null);
         _irowts         | interp(v1)  |
========================================
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 | NULL        |
```


### LAST

```sql
LAST(expr)
```

**功能说明**：统计表/超级表中某列的值最后写入的非 NULL 值。

**返回数据类型**：同应用的字段。

**适用数据类型**：所有字段。

**适用于**：表和超级表。

**使用说明**:

- 如果要返回各个列的最后（时间戳最大）一个非 NULL 值，可以使用 LAST(\*)；
- 如果结果集中的某列全部为 NULL 值，则该列的返回结果也是 NULL；如果结果集中所有列全部为 NULL 值，则不返回结果。
- 在用于超级表时，时间戳完全一样且同为最大的数据行可能有多个，那么会从中随机返回一条，而并不保证多次运行所挑选的数据行必然一致。

**示例**:
```sql
> select * from t7 ;
           ts            |     v1      |     v2      |
======================================================
 2023-08-01 01:01:00.000 | NULL        | NULL        |
 2023-08-01 01:01:01.000 |           1 | NULL        |
 2023-08-01 01:01:02.000 |           2 | NULL        |
 2023-08-01 01:01:03.000 |           3 | NULL        |
 2023-08-01 01:01:04.000 |           4 | NULL        |
 2023-08-01 01:01:05.000 |           5 | NULL        |
 2023-08-01 01:01:06.000 |           6 | NULL        |
 2023-08-01 01:01:07.000 |           7 | NULL        |
 2023-08-01 01:01:08.000 |           8 | NULL        |
 2023-08-01 01:01:09.000 |           9 | NULL        |
 2023-08-01 01:01:10.000 |          10 | NULL        |
 2023-08-01 01:01:11.000 | NULL        | NULL        |

> select last(*) from t7;
        last(ts)         |  last(v1)   |  last(v2)   |
======================================================
 2023-08-01 01:01:11.000 |          10 | NULL        |

> select ts,last(v1) from t7;
           ts            |  last(v1)   |
========================================
 2023-08-01 01:01:10.000 |          10 |

taos> select ts,last(v2) from t7;
Query OK, 0 row(s) in set (0.001065s)
```

### LAST_ROW

```sql
LAST_ROW(expr)
```

**功能说明**：返回表/超级表的最后一条记录。

**返回数据类型**：同应用的字段。

**适用数据类型**：所有字段。

**适用于**：表和超级表。

**使用说明**：

- 在用于超级表时，时间戳完全一样且同为最大的数据行可能有多个，那么会从中随机返回一条，而并不保证多次运行所挑选的数据行必然一致。
- 不能与 INTERVAL 一起使用。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |     v2      |
======================================================
 2023-08-01 01:01:00.000 | NULL        | NULL        |
 2023-08-01 01:01:01.000 |           1 | NULL        |
 2023-08-01 01:01:02.000 |           2 | NULL        |
 2023-08-01 01:01:03.000 |           3 | NULL        |
 2023-08-01 01:01:04.000 |           4 | NULL        |
 2023-08-01 01:01:05.000 |           5 | NULL        |
 2023-08-01 01:01:06.000 |           6 | NULL        |
 2023-08-01 01:01:07.000 |           7 | NULL        |
 2023-08-01 01:01:08.000 |           8 | NULL        |
 2023-08-01 01:01:09.000 |           9 | NULL        |
 2023-08-01 01:01:10.000 |          10 | NULL        |
 2023-08-01 01:01:11.000 | NULL        | NULL        |

> select last_row(*) from t7;
      last_row(ts)       | last_row(v1) | last_row(v2) |
========================================================
 2023-08-01 01:01:11.000 | NULL         | NULL         |

> select ts,last_row(v1) from t7;
           ts            | last_row(v1) |
=========================================
 2023-08-01 01:01:11.000 | NULL         |

> select ts,last_row(v2) from t7;
           ts            | last_row(v2) |
=========================================
 2023-08-01 01:01:11.000 | NULL         |
```

### MAX

```sql
MAX(expr)
```

**功能说明**：统计表/超级表中某列的值最大值。

**返回数据类型**：同应用的字段。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |     v2      |
======================================================
 2023-08-01 01:01:00.000 | NULL        | NULL        |
 2023-08-01 01:01:01.000 |           1 | NULL        |
 2023-08-01 01:01:02.000 |           2 | NULL        |
 2023-08-01 01:01:03.000 |           3 | NULL        |
 2023-08-01 01:01:04.000 |           4 | NULL        |
 2023-08-01 01:01:05.000 |           5 | NULL        |
 2023-08-01 01:01:06.000 |           6 | NULL        |
 2023-08-01 01:01:07.000 |           7 | NULL        |
 2023-08-01 01:01:08.000 |           8 | NULL        |
 2023-08-01 01:01:09.000 |           9 | NULL        |
 2023-08-01 01:01:10.000 |          10 | NULL        |
 2023-08-01 01:01:11.000 | NULL        | NULL        |

> select max(v1) from t7;
   max(v1)   |
==============
          10 |

> select max(v2) from t7;
   max(v2)   |
==============
 NULL        |
```

### MIN

```sql
MIN(expr)
```

**功能说明**：统计表/超级表中某列的值最小值。

**返回数据类型**：同应用的字段。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |     v2      |
======================================================
 2023-08-01 01:01:00.000 | NULL        | NULL        |
 2023-08-01 01:01:01.000 |           1 | NULL        |
 2023-08-01 01:01:02.000 |           2 | NULL        |
 2023-08-01 01:01:03.000 |           3 | NULL        |
 2023-08-01 01:01:04.000 |           4 | NULL        |
 2023-08-01 01:01:05.000 |           5 | NULL        |
 2023-08-01 01:01:06.000 |           6 | NULL        |
 2023-08-01 01:01:07.000 |           7 | NULL        |
 2023-08-01 01:01:08.000 |           8 | NULL        |
 2023-08-01 01:01:09.000 |           9 | NULL        |
 2023-08-01 01:01:10.000 |          10 | NULL        |
 2023-08-01 01:01:11.000 | NULL        | NULL        |

> select min(v2) from t7;
   min(v2)   |
==============
 NULL        |

> select min(v1) from t7;
   min(v1)   |
==============
           1 |
```

### MODE

```sql
MODE(expr)
```

**功能说明**：返回出现频率最高的值，若存在多个频率相同的最高值，则随机输出其中某个值。

**返回数据类型**：与输入数据类型一致。

**适用数据类型**：全部类型字段。

**适用于**：表和超级表。

**示例**:
```sql
> select * from t7;
           ts            |     v1      |     v2      |
======================================================
 2023-08-01 01:01:00.000 | NULL        | NULL        |
 2023-08-01 01:01:01.000 |           1 | NULL        |
 2023-08-01 01:01:02.000 |           2 | NULL        |
 2023-08-01 01:01:03.000 |           3 | NULL        |
 2023-08-01 01:01:04.000 |           4 | NULL        |
 2023-08-01 01:01:05.000 |           5 | NULL        |
 2023-08-01 01:01:06.000 |           6 | NULL        |
 2023-08-01 01:01:07.000 |           7 | NULL        |
 2023-08-01 01:01:08.000 |           8 | NULL        |
 2023-08-01 01:01:09.000 |           9 | NULL        |
 2023-08-01 01:01:10.000 |          10 | NULL        |
 2023-08-01 01:01:11.000 | NULL        | NULL        |
 2023-08-01 01:01:12.000 |          10 | NULL        |

> select mode(v1) from t7;
  mode(v1)   |
==============
          10 |

> select mode(v2) from t7;
  mode(v2)   |
==============
 NULL        |
```

### SAMPLE

```sql
SAMPLE(expr, k)
```

**功能说明**： 获取数据的 k 个采样值。参数 k 的合法输入范围是 1≤ k ≤ 1000。

**返回结果类型**： 同原始数据类型。

**适用数据类型**： 全部类型字段。

**嵌套子查询支持**： 适用于内层查询和外层查询。

**适用于**：表和超级表。

**示例**:
```sql
> select count(*) from db03.meters;
       count(*)        |
========================
             109847142 |
Query OK, 1 row(s) in set (2.897577s)

taos> select ts,sample(voltage,10) from db03.meters;
           ts            | sample(voltage,10) |
===============================================
 2023-08-31 07:28:22.075 |                832 |
 2023-08-31 07:44:24.141 |                843 |
 2023-08-30 20:02:05.379 |                571 |
 2023-08-31 07:39:37.149 |                 64 |
 2023-08-30 18:17:03.414 |                406 |
 2023-08-31 01:08:33.140 |                 48 |
 2023-08-30 22:24:29.888 |                665 |
 2023-08-31 03:09:20.970 |                317 |
 2023-08-31 07:52:18.062 |                809 |
 2023-08-30 23:26:56.370 |                951 |

> select ts,sample(current,10) from db03.meters;
           ts            |  sample(current,10)  |
=================================================
 2017-07-14 10:40:04.333 |            9.9600000 |
 2023-08-30 18:38:50.207 |          736.0000000 |
 2023-08-31 04:04:39.806 |           48.0000000 |
 2023-08-30 14:07:56.598 |          630.0000000 |
 2017-07-14 10:40:08.386 |            9.8000002 |
 2017-07-14 10:40:03.538 |            9.9200001 |
 2023-08-31 07:30:39.249 |          894.0000000 |
 2023-08-31 09:45:17.732 |          802.0000000 |
 2023-08-30 23:24:46.770 |          794.0000000 |
 2023-08-31 08:50:07.191 |          876.0000000 |

> select ts,sample(current,10),tbname from db03.meters;
           ts            |  sample(current,10)  |                  tbname                  |
============================================================================================
 2023-08-30 16:46:31.089 |          320.0000000 | d320                                     |
 2023-08-30 23:38:41.862 |           31.0000000 | d31                                      |
 2023-08-31 05:31:04.926 |          251.0000000 | d251                                     |
 2023-08-30 21:06:09.251 |          949.0000000 | d949                                     |
 2023-08-31 05:58:59.459 |          455.0000000 | d455                                     |
 2017-07-14 10:40:06.038 |           10.1199999 | d753                                     |
 2023-08-31 07:10:25.396 |          878.0000000 | d878                                     |
 2023-08-31 02:55:02.459 |          611.0000000 | d611                                     |
 2023-08-30 18:21:05.591 |          124.0000000 | d124                                     |
 2023-08-30 18:19:58.478 |          423.0000000 | d423                                     |

> select ts,sample(current,10),tbname from db03.meters;
           ts            |  sample(current,10)  |                  tbname                  |
============================================================================================
 2023-08-30 16:57:54.242 |          198.0000000 | d198                                     |
 2023-08-30 15:50:55.564 |          300.0000000 | d300                                     |
 2023-08-30 20:23:59.571 |          190.0000000 | d190                                     |
 2023-08-31 07:23:07.732 |          883.0000000 | d883                                     |
 2023-08-30 21:00:09.487 |          671.0000000 | d671                                     |
 2017-07-14 10:40:05.945 |            9.8000002 | d238                                     |
 2023-08-31 07:23:04.833 |          809.0000000 | d809                                     |
 2023-08-30 13:56:39.881 |          329.0000000 | d329                                     |
 2023-08-31 04:08:36.008 |          534.0000000 | d534                                     |
 2023-08-30 19:54:08.737 |           30.0000000 | d30        
```

### TAIL

```sql
TAIL(expr, k [, offset_rows])
```

**功能说明**：返回跳过最后 offset_val 个，然后取连续 k 个记录，不忽略 NULL 值。offset_val 可以不输入。此时返回最后的 k 个记录。当有 offset_val 输入的情况下，该函数功能等效于 `order by ts desc LIMIT k OFFSET offset_val`。

**参数范围**：k: [1,100] offset_val: [0,100]。

**返回数据类型**：同应用的字段。

**适用数据类型**：适合于除时间主键列外的任何类型。

**适用于**：表、超级表。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |

> select ts,tail(v1,2) from t7;
           ts            | tail(v1,2)  |
========================================
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:10.000 |          10 |

> select ts,tail(v1,2,2) from t7;
           ts            | tail(v1,2,2) |
=========================================
 2023-08-01 01:01:09.000 |            9 |
 2023-08-01 01:01:08.000 |            8 |
```

### TOP

```sql
TOP(expr, k)
```

**功能说明**： 统计表/超级表中某列的值最大 _k_ 个非 NULL 值。如果多条数据取值一样，全部取用又会超出 k 条限制时，系统会从相同值中随机选取符合要求的数量返回。

**返回数据类型**：同应用的字段。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**使用说明**:

- *k*值取值范围 1≤*k*≤100；
- 系统同时返回该记录关联的时间戳列；
- 限制：TOP 函数不支持 FILL 子句。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |

> select ts,top(v1,3) from t7;
           ts            |  top(v1,3)  |
========================================
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:12.000 |          10 |
```


### UNIQUE

```sql
UNIQUE(expr)
```

**功能说明**：返回该列数据首次出现的值。该函数功能与 distinct 相似。

**返回数据类型**：同应用的字段。

**适用数据类型**：全部类型字段。

**适用于**: 表和超级表。

**示例**:
```sql
s> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |

> select unique(v1) from t7;
 unique(v1)  |
==============
 NULL        |
           7 |
           6 |
           4 |
           2 |
           5 |
           9 |
           1 |
          10 |
           8 |
           3 |
```

## 时序数据特有函数

时序数据特有函数是 TDengine 为了满足时序数据的查询场景而量身定做出来的。在通用数据库中，实现类似功能通常需要复杂的查询语法，且效率很低。TDengine 以函数的方式内置了这些功能，最大程度的减轻了用户的使用成本。

### CSUM

```sql
CSUM(expr)
```

**功能说明**：累加和（Cumulative sum），输出行与输入行数相同。

**返回结果类型**： 输入列如果是整数类型返回值为长整型 （int64_t），浮点数返回值为双精度浮点数（Double）。无符号整数类型返回值为无符号长整型（uint64_t）。

**适用数据类型**：数值类型。

**嵌套子查询支持**： 适用于内层查询和外层查询。

**适用于**：表和超级表。

**使用说明**：

- 不支持 +、-、*、/ 运算，如 csum(col1) + csum(col2)。
- 只能与聚合（Aggregation）函数一起使用。 该函数可以应用在普通表和超级表上。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |

> select csum(v1) from t7;
       csum(v1)        |
========================
                     1 |
                     3 |
                     6 |
                    10 |
                    15 |
                    21 |
                    28 |
                    36 |
                    45 |
                    55 |
                    65 |

> select ts,csum(v1) from t7;
           ts            |       csum(v1)        |
==================================================
 2023-08-01 01:01:01.000 |                     1 |
 2023-08-01 01:01:02.000 |                     3 |
 2023-08-01 01:01:03.000 |                     6 |
 2023-08-01 01:01:04.000 |                    10 |
 2023-08-01 01:01:05.000 |                    15 |
 2023-08-01 01:01:06.000 |                    21 |
 2023-08-01 01:01:07.000 |                    28 |
 2023-08-01 01:01:08.000 |                    36 |
 2023-08-01 01:01:09.000 |                    45 |
 2023-08-01 01:01:10.000 |                    55 |
 2023-08-01 01:01:12.000 |                    65 |
```

### DERIVATIVE

```sql
DERIVATIVE(expr, time_interval, ignore_negative)

ignore_negative: {
    0
  | 1
}
```

**功能说明**：统计表中某列数值的单位变化率。其中单位时间区间的长度可以通过 time_interval 参数指定，最小可以是 1 秒（1s）；ignore_negative 参数的值可以是 0 或 1，为 1 时表示忽略负值。

**返回数据类型**：DOUBLE。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**使用说明**:

- 可以与选择相关联的列一起使用。 例如: select \_rowts, DERIVATIVE() from。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |
 2023-08-01 01:01:13.000 |          -2 |
Query OK, 14 row(s) in set (0.001077s)

taos> select _rowts,derivative(v1,1s,0) from t7;
         _rowts          |    derivative(v1,1s,0)    |
======================================================
 2023-08-01 01:01:02.000 |         1.000000000000000 |
 2023-08-01 01:01:03.000 |         1.000000000000000 |
 2023-08-01 01:01:04.000 |         1.000000000000000 |
 2023-08-01 01:01:05.000 |         1.000000000000000 |
 2023-08-01 01:01:06.000 |         1.000000000000000 |
 2023-08-01 01:01:07.000 |         1.000000000000000 |
 2023-08-01 01:01:08.000 |         1.000000000000000 |
 2023-08-01 01:01:09.000 |         1.000000000000000 |
 2023-08-01 01:01:10.000 |         1.000000000000000 |
 2023-08-01 01:01:12.000 |         0.000000000000000 |
 2023-08-01 01:01:13.000 |       -12.000000000000000 |
Query OK, 11 row(s) in set (0.001550s)

taos> select _rowts,derivative(v1,1s,1) from t7;
         _rowts          |    derivative(v1,1s,1)    |
======================================================
 2023-08-01 01:01:02.000 |         1.000000000000000 |
 2023-08-01 01:01:03.000 |         1.000000000000000 |
 2023-08-01 01:01:04.000 |         1.000000000000000 |
 2023-08-01 01:01:05.000 |         1.000000000000000 |
 2023-08-01 01:01:06.000 |         1.000000000000000 |
 2023-08-01 01:01:07.000 |         1.000000000000000 |
 2023-08-01 01:01:08.000 |         1.000000000000000 |
 2023-08-01 01:01:09.000 |         1.000000000000000 |
 2023-08-01 01:01:10.000 |         1.000000000000000 |
 2023-08-01 01:01:12.000 |         0.000000000000000 |


```

### DIFF

```sql
DIFF(expr [, ignore_negative])

ignore_negative: {
    0
  | 1
}
```

**功能说明**：统计表中某列的值与前一行对应值的差。 ignore_negative 取值为 0|1 , 可以不填，默认值为 0. 不忽略负值。ignore_negative 为 1 时表示忽略负数。

**返回数据类型**：同应用字段。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**使用说明**:

- 输出结果行数是范围内总行数减一，第一行没有结果输出。
- 可以与选择相关联的列一起使用。 例如: select \_rowts, DIFF() from。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |
 2023-08-01 01:01:13.000 |          -2 |

> select _rowts,diff(v1) from t7;
         _rowts          |       diff(v1)        |
==================================================
 1970-01-01 08:00:00.000 | NULL                  |
 2023-08-01 01:01:02.000 |                     1 |
 2023-08-01 01:01:03.000 |                     1 |
 2023-08-01 01:01:04.000 |                     1 |
 2023-08-01 01:01:05.000 |                     1 |
 2023-08-01 01:01:06.000 |                     1 |
 2023-08-01 01:01:07.000 |                     1 |
 2023-08-01 01:01:08.000 |                     1 |
 2023-08-01 01:01:09.000 |                     1 |
 2023-08-01 01:01:10.000 |                     1 |
 1970-01-01 08:00:00.000 | NULL                  |
 2023-08-01 01:01:12.000 |                     0 |
 2023-08-01 01:01:13.000 |                   -12 |

> select _rowts,diff(v1,0) from t7;
         _rowts          |      diff(v1,0)       |
==================================================
 6426-05-31 11:01:03.576 | NULL                  |
 2023-08-01 01:01:02.000 |                     1 |
 2023-08-01 01:01:03.000 |                     1 |
 2023-08-01 01:01:04.000 |                     1 |
 2023-08-01 01:01:05.000 |                     1 |
 2023-08-01 01:01:06.000 |                     1 |
 2023-08-01 01:01:07.000 |                     1 |
 2023-08-01 01:01:08.000 |                     1 |
 2023-08-01 01:01:09.000 |                     1 |
 2023-08-01 01:01:10.000 |                     1 |
 2023-08-01 01:01:10.000 | NULL                  |
 2023-08-01 01:01:12.000 |                     0 |
 2023-08-01 01:01:13.000 |                   -12 |

> select _rowts,diff(v1,1) from t7;
         _rowts          |      diff(v1,1)       |
==================================================
 1970-01-01 08:00:00.000 | NULL                  |
 2023-08-01 01:01:02.000 |                     1 |
 2023-08-01 01:01:03.000 |                     1 |
 2023-08-01 01:01:04.000 |                     1 |
 2023-08-01 01:01:05.000 |                     1 |
 2023-08-01 01:01:06.000 |                     1 |
 2023-08-01 01:01:07.000 |                     1 |
 2023-08-01 01:01:08.000 |                     1 |
 2023-08-01 01:01:09.000 |                     1 |
 2023-08-01 01:01:10.000 |                     1 |
 1970-01-01 08:00:00.000 | NULL                  |
 2023-08-01 01:01:12.000 |                     0 |
 2023-08-01 01:01:13.000 | NULL                  |
```

### IRATE

```sql
IRATE(expr)
```

**功能说明**：计算瞬时增长率。使用时间区间中最后两个样本数据来计算瞬时增长速率；如果这两个值呈递减关系，那么只取最后一个数用于计算，而不是使用二者差值。

**返回数据类型**：DOUBLE。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |
 2023-08-01 01:01:13.000 |          -2 |

> select irate(v1) from t7 where ts>='2023-08-01 01:01:10.000' and ts<='2023-08-01 01:01:12.000';
         irate(v1)         |
============================
         0.000000000000000 |

> select irate(v1) from t7 where ts>='2023-08-01 01:01:01.000' and ts<='2023-08-01 01:01:04.000';
         irate(v1)         |
============================
         1.000000000000000 |

> select _wstart,irate(v1) from t7 interval(2s);
         _wstart         |         irate(v1)         |
======================================================
 2023-08-01 01:01:00.000 |         0.000000000000000 |
 2023-08-01 01:01:02.000 |         1.000000000000000 |
 2023-08-01 01:01:04.000 |         1.000000000000000 |
 2023-08-01 01:01:06.000 |         1.000000000000000 |
 2023-08-01 01:01:08.000 |         1.000000000000000 |
 2023-08-01 01:01:10.000 |         0.000000000000000 |
 2023-08-01 01:01:12.000 |        -2.000000000000000 |
```

### MAVG

```sql
MAVG(expr, k)
```

**功能说明**： 计算连续 k 个值的移动平均数（moving average）。如果输入行数小于 k，则无结果输出。参数 k 的合法输入范围是 1≤ k ≤ 1000。

**返回结果类型**： DOUBLE。

**适用数据类型**： 数值类型。

**嵌套子查询支持**： 适用于内层查询和外层查询。

**适用于**：表和超级表。

**使用说明**：

- 不支持 +、-、*、/ 运算，如 mavg(col1, k1) + mavg(col2, k1);
- 只能与普通列，选择（Selection）、投影（Projection）函数一起使用，不能与聚合（Aggregation）函数一起使用；

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |
 2023-08-01 01:01:13.000 |          -2 |

> select ts,mavg(v1,2) from t7;
           ts            |        mavg(v1,2)         |
======================================================
 2023-08-01 01:01:02.000 |         1.500000000000000 |
 2023-08-01 01:01:03.000 |         2.500000000000000 |
 2023-08-01 01:01:04.000 |         3.500000000000000 |
 2023-08-01 01:01:05.000 |         4.500000000000000 |
 2023-08-01 01:01:06.000 |         5.500000000000000 |
 2023-08-01 01:01:07.000 |         6.500000000000000 |
 2023-08-01 01:01:08.000 |         7.500000000000000 |
 2023-08-01 01:01:09.000 |         8.500000000000000 |
 2023-08-01 01:01:10.000 |         9.500000000000000 |
 2023-08-01 01:01:12.000 |        10.000000000000000 |
 2023-08-01 01:01:13.000 |         4.000000000000000 |

> select ts,mavg(v1,4) from t7;
           ts            |        mavg(v1,4)         |
======================================================
 2023-08-01 01:01:04.000 |         2.500000000000000 |
 2023-08-01 01:01:05.000 |         3.500000000000000 |
 2023-08-01 01:01:06.000 |         4.500000000000000 |
 2023-08-01 01:01:07.000 |         5.500000000000000 |
 2023-08-01 01:01:08.000 |         6.500000000000000 |
 2023-08-01 01:01:09.000 |         7.500000000000000 |
 2023-08-01 01:01:10.000 |         8.500000000000000 |
 2023-08-01 01:01:12.000 |         9.250000000000000 |
 2023-08-01 01:01:13.000 |         6.750000000000000 |
```

### STATECOUNT

```sql
STATECOUNT(expr, oper, val)
```

**功能说明**：返回满足某个条件的连续记录的个数，结果作为新的一列追加在每行后面。条件根据参数计算，如果条件为 true 则加 1，条件为 false 则重置为-1，如果数据为 NULL，跳过该条数据。

**参数范围**：

- oper : "LT" (小于)、"GT"（大于）、"LE"（小于等于）、"GE"（大于等于）、"NE"（不等于）、"EQ"（等于），不区分大小写。
- val : 数值型

**返回结果类型**：INTEGER。

**适用数据类型**：数值类型。

**嵌套子查询支持**：不支持应用在子查询上。

**适用于**：表和超级表。

**使用说明**：

- 不能和窗口操作一起使用，例如 interval/state_window/session_window。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |
 2023-08-01 01:01:13.000 |          -2 |

> select ts,statecount(v1,'GT',5) from t7;
           ts            | statecount(v1,'GT',5) |
==================================================
 2023-08-01 01:01:00.000 | NULL                  |
 2023-08-01 01:01:01.000 |                    -1 |
 2023-08-01 01:01:02.000 |                    -1 |
 2023-08-01 01:01:03.000 |                    -1 |
 2023-08-01 01:01:04.000 |                    -1 |
 2023-08-01 01:01:05.000 |                    -1 |
 2023-08-01 01:01:06.000 |                     1 |
 2023-08-01 01:01:07.000 |                     2 |
 2023-08-01 01:01:08.000 |                     3 |
 2023-08-01 01:01:09.000 |                     4 |
 2023-08-01 01:01:10.000 |                     5 |
 2023-08-01 01:01:11.000 | NULL                  |
 2023-08-01 01:01:12.000 |                     6 |
 2023-08-01 01:01:13.000 |                    -1 |

> select ts,statecount(v1,'GT',1) from t7;
           ts            | statecount(v1,'GT',1) |
==================================================
 2023-08-01 01:01:00.000 | NULL                  |
 2023-08-01 01:01:01.000 |                    -1 |
 2023-08-01 01:01:02.000 |                     1 |
 2023-08-01 01:01:03.000 |                     2 |
 2023-08-01 01:01:04.000 |                     3 |
 2023-08-01 01:01:05.000 |                     4 |
 2023-08-01 01:01:06.000 |                     5 |
 2023-08-01 01:01:07.000 |                     6 |
 2023-08-01 01:01:08.000 |                     7 |
 2023-08-01 01:01:09.000 |                     8 |
 2023-08-01 01:01:10.000 |                     9 |
 2023-08-01 01:01:11.000 | NULL                  |
 2023-08-01 01:01:12.000 |                    10 |
 2023-08-01 01:01:13.000 |                    -1 |
```

### STATEDURATION

```sql
STATEDURATION(expr, oper, val, unit)
```

**功能说明**：返回满足某个条件的连续记录的时间长度，结果作为新的一列追加在每行后面。条件根据参数计算，如果条件为 true 则加上两个记录之间的时间长度（第一个满足条件的记录时间长度记为 0），条件为 false 则重置为-1，如果数据为 NULL，跳过该条数据。

**参数范围**：

- oper : `'LT'` (小于)、`'GT'`（大于）、`'LE'`（小于等于）、`'GE'`（大于等于）、`'NE'`（不等于）、`'EQ'`（等于），不区分大小写，但需要用`''`包括。
- val : 数值型
- unit : 时间长度的单位，可取值时间单位： 1b(纳秒), 1u(微秒)，1a(毫秒)，1s(秒)，1m(分)，1h(小时)，1d(天), 1w(周)。如果省略，默认为当前数据库精度。

**返回结果类型**：INTEGER。

**适用数据类型**：数值类型。

**嵌套子查询支持**：不支持应用在子查询上。

**适用于**：表和超级表。

**使用说明**：

- 不能和窗口操作一起使用，例如 interval/state_window/session_window。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |
 2023-08-01 01:01:13.000 |          -2 |

> select  ts,stateduration(v1,'GT',5,1a) from t7;
           ts            | stateduration(v1,'GT',5,1a) |
========================================================
 2023-08-01 01:01:00.000 | NULL                        |
 2023-08-01 01:01:01.000 |                          -1 |
 2023-08-01 01:01:02.000 |                          -1 |
 2023-08-01 01:01:03.000 |                          -1 |
 2023-08-01 01:01:04.000 |                          -1 |
 2023-08-01 01:01:05.000 |                          -1 |
 2023-08-01 01:01:06.000 |                           0 |
 2023-08-01 01:01:07.000 |                        1000 |
 2023-08-01 01:01:08.000 |                        2000 |
 2023-08-01 01:01:09.000 |                        3000 |
 2023-08-01 01:01:10.000 |                        4000 |
 2023-08-01 01:01:11.000 | NULL                        |
 2023-08-01 01:01:12.000 |                        6000 |
 2023-08-01 01:01:13.000 |                          -1 |

> select  ts,stateduration(v1,'GT',5,1s) from t7;
           ts            | stateduration(v1,'GT',5,1s) |
========================================================
 2023-08-01 01:01:00.000 | NULL                        |
 2023-08-01 01:01:01.000 |                          -1 |
 2023-08-01 01:01:02.000 |                          -1 |
 2023-08-01 01:01:03.000 |                          -1 |
 2023-08-01 01:01:04.000 |                          -1 |
 2023-08-01 01:01:05.000 |                          -1 |
 2023-08-01 01:01:06.000 |                           0 |
 2023-08-01 01:01:07.000 |                           1 |
 2023-08-01 01:01:08.000 |                           2 |
 2023-08-01 01:01:09.000 |                           3 |
 2023-08-01 01:01:10.000 |                           4 |
 2023-08-01 01:01:11.000 | NULL                        |
 2023-08-01 01:01:12.000 |                           6 |
 2023-08-01 01:01:13.000 |                          -1 |

> select  ts,stateduration(v1,'GT',5,1m) from t7;
           ts            | stateduration(v1,'GT',5,1m) |
========================================================
 2023-08-01 01:01:00.000 | NULL                        |
 2023-08-01 01:01:01.000 |                          -1 |
 2023-08-01 01:01:02.000 |                          -1 |
 2023-08-01 01:01:03.000 |                          -1 |
 2023-08-01 01:01:04.000 |                          -1 |
 2023-08-01 01:01:05.000 |                          -1 |
 2023-08-01 01:01:06.000 |                           0 |
 2023-08-01 01:01:07.000 |                           0 |
 2023-08-01 01:01:08.000 |                           0 |
 2023-08-01 01:01:09.000 |                           0 |
 2023-08-01 01:01:10.000 |                           0 |
 2023-08-01 01:01:11.000 | NULL                        |
 2023-08-01 01:01:12.000 |                           0 |
 2023-08-01 01:01:13.000 |                          -1 |
```

### TWA

```sql
TWA(expr)
```

**功能说明**：时间加权平均函数。统计表中某列在一段时间内的时间加权平均。

**返回数据类型**：DOUBLE。

**适用数据类型**：数值类型。

**适用于**：表和超级表。

**示例**:
```sql
> select ts,v1 from t7;
           ts            |     v1      |
========================================
 2023-08-01 01:01:00.000 | NULL        |
 2023-08-01 01:01:01.000 |           1 |
 2023-08-01 01:01:02.000 |           2 |
 2023-08-01 01:01:03.000 |           3 |
 2023-08-01 01:01:04.000 |           4 |
 2023-08-01 01:01:05.000 |           5 |
 2023-08-01 01:01:06.000 |           6 |
 2023-08-01 01:01:07.000 |           7 |
 2023-08-01 01:01:08.000 |           8 |
 2023-08-01 01:01:09.000 |           9 |
 2023-08-01 01:01:10.000 |          10 |
 2023-08-01 01:01:11.000 | NULL        |
 2023-08-01 01:01:12.000 |          10 |
 2023-08-01 01:01:13.000 |          -2 |

> select _wstart,twa(v1) from t7 interval(1s);
         _wstart         |          twa(v1)          |
======================================================
 2023-08-01 01:01:00.000 |         0.000000000000000 |
 2023-08-01 01:01:01.000 |         1.499500000000000 |
 2023-08-01 01:01:02.000 |         2.499500000000000 |
 2023-08-01 01:01:03.000 |         3.499500000000000 |
 2023-08-01 01:01:04.000 |         4.499499999999999 |
 2023-08-01 01:01:05.000 |         5.499499999999999 |
 2023-08-01 01:01:06.000 |         6.499499999999999 |
 2023-08-01 01:01:07.000 |         7.499499999999999 |
 2023-08-01 01:01:08.000 |         8.499500000000001 |
 2023-08-01 01:01:09.000 |         9.499500000000001 |
 2023-08-01 01:01:10.000 |         5.005000000000000 |
 2023-08-01 01:01:11.000 |         0.000000000000000 |
 2023-08-01 01:01:12.000 |         4.006000976562500 |
 2023-08-01 01:01:13.000 |        -2.000000000000000 |

> select _wstart,twa(v1) from t7 interval(2s);
         _wstart         |          twa(v1)          |
======================================================
 2023-08-01 01:01:00.000 |         1.499500000000000 |
 2023-08-01 01:01:02.000 |         2.999500000000000 |
 2023-08-01 01:01:04.000 |         4.999499999999999 |
 2023-08-01 01:01:06.000 |         6.999499999999999 |
 2023-08-01 01:01:08.000 |         8.999500000000001 |
 2023-08-01 01:01:10.000 |         9.995000000000001 |
 2023-08-01 01:01:12.000 |         3.999999511718750 |
```

## 系统信息函数

### DATABASE

```sql
SELECT DATABASE();
```

**说明**：返回当前登录的数据库。如果登录的时候没有指定默认数据库，且没有使用USE命令切换数据库，则返回NULL。

**示例**:
```sql
> use test;
Database changed.

> select database();
 database() |
=============
 test       |

> use db03;
Database changed.

> select database();
 database() |
=============
 db03       |
```

### CLIENT_VERSION

```sql
SELECT CLIENT_VERSION();
```

**说明**：返回客户端版本。

**示例**:
```sql
> select client_version();
 client_version() |
===================
 3.1.0.3          |
```

### SERVER_VERSION

```sql
SELECT SERVER_VERSION();
```

**说明**：返回服务端版本。

**示例**:
```sql
> select server_version();
 server_version() |
===================
 3.1.0.3          |
```

### SERVER_STATUS

```sql
SELECT SERVER_STATUS();
```

**说明**：检测服务端是否所有 dnode 都在线，如果是则返回成功(返回 1)，否则返回无法建立连接的错误。此函数不建议使用！！！

**示例**:
```sql
> select server_status();
 server_status() |
==================
               1 |
```

### CURRENT_USER

```sql
SELECT CURRENT_USER();
```

**说明**：获取当前用户。

**示例**：
```sql
> select current_user();
 current_user() |
=================
 root@c1-124    |

```
